; ============================================================================
; Copyright 1976-2025 Microsoft Corp.
; Copyright 2012-2025 S. V. Nickolas.
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the Software), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
; copies of the Software, and to permit persons to whom the Software is
; furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in
; all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE, ARISING FROM,
; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
; THE SOFTWARE.
; ============================================================================

; This code last touched: 25121516

; ============================================================================
; The current understanding of the legal status of this code is as follows:
;   1. The majority of this code is just Microsoft 6502 BASIC, the same code
;      that Microsoft themselves recently reissued under the X11/Expat
;      license.
;   2. The rest could have been done by either Microsoft, Vtech or Central
;      Point Software, but because of a particular affinity in the code to the
;      Franklin Ace 500 BASIC, copyrighted to Franklin Electronics and
;      Microsoft, it is almost certain that it was at least mostly written by
;      Microsoft.
;   3. Whatever remains is probably too little for anyone, least of all Vtech
;      or whoever owns Central Point now, to care about.
; Therefore, it is my non-legal opinion that this code is fully safe to use
; under the copyright terms described herein.  (S. V. Nickolas, Dec. 15, 2025)
;
; This code is based on the following:
;   Official Microsoft 6502 BASIC source code
;   Disassembly of Applesoft BASIC by Bob Sander-Cederlof
;   Disassembly of Laser 128 FPBASIC by S. V. Nickolas using 6502bench
;   Separate disassembly of Laser 128 FPBASIC by S. V. Nickolas using DASMC02
;   Initial analysis of Laser 128 FPBASIC and Franklin FPBASIC with IDA
; Current status:
;   It builds, but it hasn't been fully RE'd, and some functions which spill
;   outside the 10K space normally allocated to FPBASIC aren't here (yet).
; Plans:
;   1. Finish the disassembly, and reconform some of the labels from those
;      used by Sander-Cederlof to those used by Microsoft.
;   2. Attempt to clean up the code to reduce 65C02isms and code spaghetti.
;   3. Put the tokens for tape commands back, but make them NOPs or IQERRs.
;   4. Reinstate some of the original comments and write new ones.
; The intention is that, once this is polished off a bit, it could be used to
; create a new set of MIT-licensed compatibility firmwares for Apple ][+, //e
; and/or //c computers, mainly for use in emulators.
; ============================================================================

; ============================================================================
; Convenience macros.
; ============================================================================

; ----------------------------------------------------------------------------
; ASCII string with all high bits set (Apple ][ format).
; ----------------------------------------------------------------------------

.macro    asch      str
          .repeat   .strlen(str), I
                    .byte     .strat(str,I)+$80
          .endrep
.endmacro

; ----------------------------------------------------------------------------
; ASCII string with high bit terminal (used frequently in FPBASIC).
; ----------------------------------------------------------------------------

.macro    asct      str
          .repeat   .strlen(str)-1, I
                    .byte     .strat(str,I)
          .endrep
          .byte     .strat(str,.strlen(str)-1)+$80
.endmacro

          .pc02

usrvec     =        $0A

count      =        $0F
dores      =        $13
inpflg     =        $15
cqprmp     =        $33
linnum     =        $50
index      =        $5E
dest       =        $60
txttab     =        $67
vartab     =        $69
strend     =        $6D
fretop     =        $6F
memsiz     =        $73
curlin     =        $75
forpnt     =        $85
temp1      =        $93
highds     =        $94
hightr     =        $96
lowtr      =        $9B
fac        =        $9D
prgend     =        $AF
txtptr     =        $B8
protect    =        $D6
errflg     =        $D8

stack      =        $0100
inpbuf     =        $0200

ampvec     =        $03F5

monspc     =        $F94A
home       =        $FC58
getch      =        $FD0C
getlin     =        $FD6A
putch      =        $FDED

          .org      $D000

; ============================================================================
; BASIC tokens
; ============================================================================

tk_end     =        $80
tk_for     =        $81
tk_next    =        $82
tk_data    =        $83
tk_input   =        $84
tk_del     =        $85
tk_dim     =        $86
tk_read    =        $87
tk_gr      =        $88
tk_text    =        $89
tk_prno    =        $8A
tk_inno    =        $8B
tk_call    =        $8C
tk_plot    =        $8D
tk_hlin    =        $8E
tk_vlin    =        $8F
tk_hgr2    =        $90
tk_hgr     =        $91
tk_hcolor  =        $92
tk_hplot   =        $93
tk_draw    =        $94
tk_xdraw   =        $95
tk_htab    =        $96
tk_home    =        $97
tk_rot     =        $98
tk_scale   =        $99
tk_shload  =        $9A
tk_trace   =        $9B
tk_notrc   =        $9C
tk_normal  =        $9D
tk_invers  =        $9E
tk_flash   =        $9F
tk_color   =        $A0
tk_pop     =        $A1
tk_vtab    =        $A2
tk_himem   =        $A3
tk_lomem   =        $A4
tk_onerr   =        $A5
tk_resume  =        $A6
tk_recall  =        $A7
tk_store   =        $A8
tk_speed   =        $A9
tk_let     =        $AA
tk_goto    =        $AB
tk_run     =        $AC
tk_if      =        $AD
tk_restor  =        $AE
tk_amp     =        $AF
tk_gosub   =        $B0
tk_return  =        $B1
tk_rem     =        $B2
tk_stop    =        $B3
tk_on      =        $B4
tk_wait    =        $B5
tk_load    =        $B6
tk_save    =        $B7
tk_def     =        $B8
tk_poke    =        $B9
tk_print   =        $BA
tk_cont    =        $BB
tk_list    =        $BC
tk_clear   =        $BD
tk_get     =        $BE
tk_new     =        $BF
tk_tab     =        $C0
tk_to      =        $C1
tk_fn      =        $C2
tk_spc     =        $C3
tk_then    =        $C4
tk_at      =        $C5
tk_not     =        $C6
tk_step    =        $C7
tk_add     =        $C8
tk_sub     =        $C9
tk_mul     =        $CA
tk_div     =        $CB
tk_pwr     =        $CC
tk_and     =        $CD
tk_or      =        $CE
tk_gt      =        $CF
tk_equ     =        $D0
tk_lt      =        $D1
tk_sgn     =        $D2
tk_int     =        $D3
tk_abs     =        $D4
tk_usr     =        $D5
tk_fre     =        $D6
tk_scrn    =        $D7
tk_pdl     =        $D8
tk_pos     =        $D9
tk_sqr     =        $DA
tk_rnd     =        $DB
tk_log     =        $DC
tk_exp     =        $DD
tk_cos     =        $DE
tk_sin     =        $DF
tk_tan     =        $E0
tk_atn     =        $E1
tk_peek    =        $E2
tk_len     =        $E3
tk_str     =        $E4
tk_val     =        $E5
tk_asc     =        $E6
tk_chr     =        $E7
tk_left    =        $E8
tk_right   =        $E9
tk_mid     =        $EA

; ============================================================================
; Token address table
; ============================================================================

; ----------------------------------------------------------------------------
; Because the commands are invoked by pushing an address on the stack and
; doing an RTS, the addresses must be one lower than the actual addresses.
; ----------------------------------------------------------------------------

tokadr:   .word     end-1
          .word     for-1
          .word     next-1
          .word     data-1
          .word     input-1
          .word     del-1
          .word     dim-1
          .word     read-1
          .word     gr-1
          .word     text-1
          .word     pr_number-1
          .word     in_number-1
          .word     call-1
          .word     plot-1
          .word     hlin-1
          .word     vlin-1
          .word     hgr2-1
          .word     hgr-1
          .word     hcolor-1
          .word     hplot-1
          .word     draw-1
          .word     xdraw-1
          .word     htab-1
          .word     home-1
          .word     rot-1
          .word     scale-1
          .word     userr-1
          .word     trace-1
          .word     notrace-1
          .word     normal-1
          .word     inverse-1
          .word     flash-1
          .word     color-1
          .word     pop-1
          .word     fpvtab-1
          .word     himem-1
          .word     lomem-1
          .word     onerr-1
          .word     resume-1
          .word     userr-1
          .word     userr-1
          .word     speed-1
          .word     let-1
          .word     goto-1
          .word     run-1
          .word     if-1
          .word     restore-1
          .word     ampvec-1
          .word     gosub-1
          .word     pop-1
          .word     rem-1
          .word     stop-1
          .word     ongoto-1
          .word     wait-1
          .word     userr-1
          .word     userr-1
          .word     def-1
          .word     poke-1
          .word     print-1
          .word     cont-1
          .word     list-1
          .word     clear-1
          .word     get-1
          .word     new-1
          .word     sgn
          .word     int
          .word     abs
          .word     usrvec
          .word     fre
          .word     error
          .word     pdl
          .word     pos
          .word     sqr
          .word     rnd
          .word     log
          .word     exp
          .word     cos
          .word     sin
          .word     tan
          .word     atn
          .word     peek
          .word     len
          .word     str
          .word     val
          .word     asc
          .word     chrstr
          .word     leftstr
          .word     rightstr
          .word     midstr

mathtbl:  .byte     $79
          .word     faddt-1
          .byte     $79
          .word     fsubt-1
          .byte     $7b
          .word     TE982-1
          .byte     $7b
          .word     fdivt-1
          .byte     $7d
          .word     TEE97-1
          .byte     $50
          .word     do_and-1
          .byte     $46
          .word     or-1
          .byte     $7f
          .word     negop-1
          .byte     $7f
          .word     equop-1
          .byte     $64
          .word     relops-1

; ============================================================================
; The Laser 128 version of BASIC simply removes SHLOAD, LOAD and SAVE tokens,
; replacing them with 0x80.  This makes some code that uses & metacommands
; unusable from the command line.  The tokens are restored, but they'll cause
; Undefined Statement errors if used.
; ============================================================================

toktbl:   asct      "END"
          asct      "FOR"
          asct      "NEXT"
          asct      "DATA"
          asct      "INPUT"
          asct      "DEL"
          asct      "DIM"
          asct      "READ"
          asct      "GR"
          asct      "TEXT"
          asct      "PR#"
          asct      "IN#"
          asct      "CALL"
          asct      "PLOT"
          asct      "HLIN"
          asct      "VLIN"
          asct      "HGR2"
          asct      "HGR"
          asct      "HCOLOR="
          asct      "HPLOT"
          asct      "DRAW"
          asct      "XDRAW"
          asct      "HTAB"
          asct      "HOME"
          asct      "ROT="
          asct      "SCALE="
          asct      "SHLOAD"
          asct      "TRACE"
          asct      "NOTRACE"
          asct      "NORMAL"
          asct      "INVERSE"
          asct      "FLASH"
          asct      "COLOR="
          asct      "POP"
          asct      "VTAB"
          asct      "HIMEM:"
          asct      "LOMEM:"
          asct      "ONERR"
          asct      "RESUME"
          asct      "RECALL"
          asct      "STORE"
          asct      "SPEED="
          asct      "LET"
          asct      "GOTO"
          asct      "RUN"
          asct      "IF"
          asct      "RESTORE"
          asct      "&"
          asct      "GOSUB"
          asct      "RETURN"
          asct      "REM"
          asct      "STOP"
          asct      "ON"
          asct      "WAIT"
          asct      "LOAD"
          asct      "SAVE"
          asct      "DEF"
          asct      "POKE"
          asct      "PRINT"
          asct      "CONT"
          asct      "LIST"
          asct      "CLEAR"
          asct      "GET"
          asct      "NEW"
          asct      "TAB("
          asct      "TO"
          asct      "FN"
          asct      "SPC("
          asct      "THEN"
          asct      "AT"
          asct      "NOT"
          asct      "STEP"
          asct      "+"
          asct      "-"
          asct      "*"
          asct      "/"
          asct      "^"
          asct      "AND"
          asct      "OR"
          asct      ">"
          asct      "="
          asct      "<"
          asct      "SGN"
          asct      "INT"
          asct      "ABS"
          asct      "USR"
          asct      "FRE"
          asct      "SCRN("
          asct      "PDL"
          asct      "POS"
          asct      "SQR"
          asct      "RND"
          asct      "LOG"
          asct      "EXP"
          asct      "COS"
          asct      "SIN"
          asct      "TAN"
          asct      "ATN"
          asct      "PEEK"
          asct      "LEN"
          asct      "STR$"
          asct      "VAL"
          asct      "ASC"
          asct      "CHR$"
          asct      "LEFT$"
          asct      "RIGHT$"
          asct      "MID$"

          .res      $D260-*, $FF

errtab:
e_nf       =        *-errtab
          asct      "NEXT WITHOUT FOR"
e_sn       =        *-errtab
          asct      "SYNTAX"
e_rg       =        *-errtab
          asct      "RETURN WITHOUT GOSUB"
e_od       =        *-errtab
          asct      "OUT OF DATA"
e_fc       =        *-errtab
          asct      "ILLEGAL QUANTITY"
e_ov       =        *-errtab
          asct      "OVERFLOW"
e_om       =        *-errtab
          asct      "OUT OF MEMORY"
e_ul       =        *-errtab
          asct      "UNDEF'D STATEMENT"
e_bs       =        *-errtab
          asct      "BAD SUBSCRIPT"
e_dd       =        *-errtab
          asct      "REDIM'D ARRAY"
e_dz       =        *-errtab
          asct      "DIVISION BY ZERO"
e_id       =        *-errtab
          asct      "ILLEGAL DIRECT"
e_tm       =        *-errtab
          asct      "TYPE MISMATCH"
e_ls       =        *-errtab
          asct      "STRING TOO LONG"
e_os       =        *-errtab
          asct      "FORMULA TOO COMPLEX"
e_cn       =        *-errtab
          asct      "CAN'T CONTINUE"
e_uf       =        *-errtab
          asct      "UNDEF'D FUNCTION"

m_err:    .byte     " ERROR", 7, 0
m_in:     .byte     " IN ", 0
m_brk:    .byte     13, "BREAK", 7, 0

; ============================================================================
; General storage management routines
; ============================================================================

; ----------------------------------------------------------------------------
; Find a FOR entry on the stack via VARPNT.
; ----------------------------------------------------------------------------

fndfor:   tsx                           ; Load X with stack pointer
          inx                           ; Ignore adr(NEWSTT) and RTS addr.
          inx
          inx
          inx
@1:       lda       stack+1, x          ; Get stack entry.
          cmp       #tk_for             ; Is it a FOR token?
          bne       @4                  ; No; no FOR loops with this pointer.
          lda       forpnt+1            ; Get high.
          bne       @2
          lda       stack+2, x          ; Pointer is zero, so assume this one.
          sta       forpnt
          lda       stack+3, x
          sta       forpnt+1
@2:       cmp       stack+3, x
          bne       @3                  ; Not this one.
          lda       forpnt              ; Get down.
          cmp       stack+2, x
          beq       @4                  ; We gotcha!
@3:       txa
          clc                           ; Increase X by 18.
          adc       #18
          tax                           ; Result back into X.
          bne       @1
@4:       rts

; ----------------------------------------------------------------------------
; This is the block transfer routine.
; It makes space by shoving everything forward.
;
; On entry:
;   YA = HIGHDS (for reason).
;   HIGHDS = destination of high address.
;   LOWTR = lowest address to be transferred.
;   HIGHTR = highest address to be transferred.
;
; A check is made to ascertain that a reasonable amount of space exists
; between the bottom of strings and the highest location transferred into.
;
; On exit:
;   LOWTR - unchanged.
;   HIGHTR - LOWTR minus $80.
;   HIGHDS - lowest address transferred-into minus $80.
; ----------------------------------------------------------------------------

bltu:     jsr       reason              ; Ascertain that string space will not
                                        ; be overrun.
          sta       strend
          sty       strend+1
bltuc:    sec                           ; Prepare to subtract.
          lda       hightr
          sbc       lowtr               ; Compute number of things to move.
          sta       index               ; Save for later.
          tay
          lda       hightr+1
          sbc       lowtr+1
          tax                           ; Put it in a counter register.
          inx                           ; So that counter algorithm works.
          tya                           ; See if low part of count is 0.
          beq       @4                  ; Yes; go start moving blocks.
          lda       hightr              ; No; must modify base address.
          sec
          sbc       index               ; Borrow is off since HIGHTR>LOWTR.
          sta       hightr              ; Save modified base address.
          bcs       @1                  ; If no borrow, go shove it.
          dec       hightr+1            ; Borrow implies sub 1 from high byte
          sec
@1:       lda       highds              ; Modify base of destination address
          sbc       index
          sta       highds
          bcs       @3                  ; No borrow.
          dec       highds+1            ; Decrement high-order byte.
          bcc       @3                  ; ALWAYS
@2:       lda       (hightr), y         ; Fetch byte to move
          sta       (highds), y         ; Move it in, move it out.
@3:       dey
          bne       @2
          lda       (hightr), y         ; Move last of the block.
          sta       (highds), y
@4:       dec       hightr+1
          dec       highds+1            ; Start on new blocks.
          dex
          bne       @3
          rts

; ----------------------------------------------------------------------------
; This routine is used to ascertain that a given number of locations remain
; available for the stack.  It must be called by any routine which puts an
; arbitrary amount of stuff on the stack, e.g., any recursive routine like
; FRMEVL.  It is also called by routines such as GOSUB and FOR which make
; permanent entries on the stack.  Routines which merely use and free up the
; guaranteed NUMLEV locations need not call this.
; ----------------------------------------------------------------------------

getstk:   asl                           ; Double A.  Note: Clears carry
          adc       #54
          bcs       omerr
          sta       index
          tsx                           ; Get stacked
          cpx       index
          bcc       omerr               ; If stack < INDEX1, out of memory
          rts

; ----------------------------------------------------------------------------
; YA is a certain address.  REASON makes sure it is less than FRETOP.
; ----------------------------------------------------------------------------

reason:   cpy       fretop+1
          bcc       @4
          bne       @1                  ; Garbage collect
          cmp       fretop
          bcc       @4
@1:       pha
          ldx       #$09                ; if TEMPF2 has zero in between
          tya
@2:       pha
          lda       highds-1, x         ; Save HIGHDS on stack
          dex
          bpl       @2                  ; Put 8 on stack
          jsr       garba2              ; Do garbage collection
          ldx       #$f7
@3:       pla
          sta       fac, x              ; Restore after garbage collection
          inx
          bmi       @3
          pla
          tay
          pla                           ; Restore A and Y
          cpy       fretop+1            ; Compare highs
          bcc       @4
          bne       omerr               ; Higher is bad
          cmp       fretop              ; And lows
          bcs       omerr
@4:       rts

omerr:    ldx       #e_om
error:    ldy       errflg              ; Check for ONERR
          beq       @1                  ; No; continue
          jmp       handlerr            ; Yes; override
@1:       jsr       crdo                ; Output CRLF
          jsr       outqst              ; Print question mark
@2:       lda       errtab, x           ; Print error message
          pha                           ; Save character
          jsr       outdo
          inx
          pla                           ; Retrieve character
          bpl       @2                  ; High bit on, continue
          jsr       stkini              ; Reset stack and flags
          lda       #<m_err             ; Get pointer to " ERROR"
          ldy       #>m_err
errfin:   jsr       strout              ; Output (also used by BREAK)
          ldy       curlin+1
          iny                           ; Was number 64000?
          beq       ready               ; Yes; don't print line number
          jsr       inprt

; ----------------------------------------------------------------------------
; Warm restart point (vectored from $0000, $03D0, $E003)
; ----------------------------------------------------------------------------

ready:    jsr       crdo                ; Output CRLF
          ldx       #']'+$80            ; Prompt character
          stz       errflg              ; Clear ONERR flag
          jsr       inlin2              ; Get line from user
          stx       txtptr
          sty       txtptr+1
          jsr       chrget
          tax                           ; Set Z based on A
                                        ; (distinguish : and 0)
          beq       ready               ; Blank line; go back to top
          ldx       #$FF                ; Set DIRECT line number
          stx       curlin+1
          bcc       islin               ; Is a line number.
          jsr       crunch              ; Tokenize
          jmp       gone                ; Do it, maggot.

islin:    ldx       prgend+1            ; Squash variable table
          ldy       prgend
          stx       vartab+1
          sty       vartab

; ============================================================================
; The Laser code shown here is heavily altered, and includes some of the code
; for the DEL command.  This code, or at least to FIX_LINKS (D4F2), should
; probably be reverted to the stock code, which is Microsoft's, as far as can
; be reasonably achieved.
; ============================================================================

          jsr       linget
          jsr       crunch
          sty       count
          jsr       fndlin
          bcc       nodel
          jsr       LF336
          lda       (lowtr)
          tax
          ldy       #$01
          lda       (lowtr), y
          jsr       LF33F
          bra       nodel

LD480:    jsr       linget
          jsr       fndlin
          jsr       LF336
          jsr       chkcom
          jsr       linget
          jsr       fndlin
          bcc       @1
          lda       (lowtr)
          tax
          ldy       #$01
          lda       (lowtr), y
          bra       @2

@1:       ldx       lowtr
          lda       lowtr+1
@2:       cpx       dest
          pha
          sbc       dest+1
          pla
          bcc       @3
          jsr       LF33F
          bra       fix_links

@3:       rts

          .res      6,$ff

nodel:    ldy       inpbuf
          beq       fix_links
          lda       vartab
          sta       hightr
          clc
          adc       count
          sta       highds
          ldy       vartab+1
          sty       hightr+1
          bcc       @LD4CA
          iny
@LD4CA:   sty       highds+1
          ldx       memsiz+1
          stx       fretop+1
          ldx       memsiz
          stx       fretop
          jsr       bltu
          ldx       #$01
@LD4D9:   lda       strend, x
          sta       vartab, x
          lda       linnum, x
          sta       $01FE, x
          dex
          bpl       @LD4D9
          ldy       count
@LD4E7:   dey
          lda       $01FC, y
          sta       (lowtr), y
          tya
          bne       @LD4E7
          nop
          nop
fix_links:
          jsr       runc
          lda       txttab
          ldy       txttab+1
          sta       index
          sty       index+1
          clc
@LD4FE:   ldy       #$01
          lda       (index), y
          beq       @LD520
          ldy       #$04
@LD506:   iny
          lda       (index), y
          bne       @LD506
          iny
          tya
          adc       index
          tax
          sta       (index)
          lda       index+1
          adc       #$00
          ldy       #$01
          sta       (index), y
          stx       index
          sta       index+1
          bne       @LD4FE              ; ALWAYS

@LD520:   lda       vartab
          ldy       vartab+1
          sta       prgend
          sty       prgend+1
          jmp       ready

          .byte     $ff

inlin:    ldx       #$80
inlin2:   stx       cqprmp
          jmp       cqinln

          nop
          nop
          nop
          nop
          nop
          nop

          jmp       LD8BF

LD53C:    iny
          sta       $01FB, y
LD540:    inx
          lda       $01FF, x
          bne       LD53C
          rts

LD547:    lda       #$d0
          sta       fac
          lda       #$d0                ; REDUNDANT
          sta       fac+1
          rts

          .byte     $ff
          .byte     $ff
          .byte     $ff

inchr:    jsr       getch
          and       #$7F
          rts

; ============================================================================
; Trying to clean out 65C02isms here.  This code is a bit grungy.
; ============================================================================

crunch:   ldx       txtptr
          nop
          ldy       #$04
          sty       dores
          bit       protect
          bpl       parse
          pla
          pla
          jsr       runc
          jmp       newstt

parse:    inx
          lda       inpbuf-1, x
          bne       @LD575
          jmp       @LD5FB

@LD575:   cmp       #' '
          beq       parse
          cmp       #'?'
          bne       @LD581
          lda       #tk_print
          bne       @LD5E0              ; ALWAYS

@LD581:   cmp       #'0'
          bcc       @LD589
          cmp       #'9'+1
          bcc       @LD5E0
@LD589:   jsr       LD547
          lda       #$80
          sta       dores
          stx       inpflg
          bne       @LD5B0              ; ALWAYS

@LD594:   inc       fac
          bne       @LD59A
          inc       fac+1
@LD59A:   lda       (fac)
          bpl       @LD594
          ldx       inpflg
          inc       dores
          lda       dores
          cmp       #tk_mid+1
          beq       @LD5DA
          dex
@LD5A9:   inc       fac
          bne       @LD5AF
          inc       fac+1
@LD5AF:   inx
@LD5B0:   lda       $01ff, x
          cmp       #$20
          beq       @LD5AF
          jsr       LF3CB
          eor       (fac)
          beq       @LD5A9
          and       #$7f
          bne       @LD59A
          lda       dores
          cmp       #$c5
          bne       @LD5E0
          lda       inpbuf, x
          jsr       LF3CB
          cmp       #'O'
          beq       @LD59A
          cmp       #'N'
          beq       @LD59A
          lda       dores
          bra       @LD5E0

@LD5DA:   lda       $01ff, x
          jsr       LF3CB
@LD5E0:   iny
          sta       $01fb, y
          cmp       #tk_rem
          beq       @LD5F8
          cmp       #tk_data
          beq       @LD608
          cmp       #'"'
          bne       @LD5F5
          jsr       LF3B9
          beq       @LD5FB
@LD5F5:   jmp       parse

@LD5F8:   jsr       LD540
@LD5FB:   iny
          sta       $01fb, y
          sta       $01fd, y
          dec
          sta       txtptr
          dec       txtptr+1
          rts

@LD608:   jsr       LF3A5
          beq       @LD5FB
          bne       @LD5F5              ; ALWAYS

LD60F:    iny
          bne       @LD615
          inc       fac+1
          nop
@LD615:   lda       (fac), y
          rts

          .byte     $ff
          .byte     $ff

fndlin:   lda       txttab
          ldx       txttab+1
LD61E:    ldy       #$01
          sta       lowtr
          stx       lowtr+1
          lda       (lowtr), y
          beq       @LD647
          iny
          iny
          lda       linnum+1
          cmp       (lowtr), y
          bcc       LD648
          beq       @LD635
          dey
          bne       @LD63E
@LD635:   lda       linnum
          dey
          cmp       (lowtr), y
          bcc       LD648
          beq       LD648
@LD63E:   dey
          lda       (lowtr), y
          tax
          dey
          lda       (lowtr), y
          bcs       LD61E

@LD647:   clc
LD648:    rts

new:      bne       LD648
scrtch:   lda       #$00
          tay
          sta       protect
          sta       (txttab), y
          iny
          sta       (txttab), y
          lda       txttab
          adc       #$02
          sta       prgend
          sta       vartab
          lda       txttab+1
          adc       #$00
          sta       prgend+1
          sta       vartab+1
runc:     jsr       stxtpt
          lda       #$00
clear:    bne       LD696
clearc:   lda       memsiz
          ldy       memsiz+1
          sta       fretop
          sty       fretop+1
          lda       vartab
          ldy       vartab+1
          sta       $6b
          sty       $6c
          sta       strend
          sty       strend+1
          jsr       restore
stkini:   ldx       #$55
          stx       $52
          pla
          tay
          pla
          ldx       #$f8
          txs
          pha
          tya
          pha
          lda       #$00
          sta       $7a
          sta       $14
LD696:    rts

stxtpt:   clc
          lda       txttab
          adc       #$ff
          sta       txtptr
          lda       txttab+1
          adc       #$ff
          sta       txtptr+1
          rts

list:     jsr       linget
          jsr       fndlin
          jsr       L00B7
          cmp       #','
          beq       @LD6B6
          cmp       #tk_sub
          bne       @LD6BC
@LD6B6:   jsr       chrget
          jsr       linget
@LD6BC:   pla
          pla
          ldy       #$01
@LD6C0:   lda       (lowtr), y
          beq       @LD6EC
          jsr       iscntc
          jsr       crdo
          iny
          lda       linnum
          ora       linnum+1
          beq       @LD6DC
          lda       linnum
          cmp       (lowtr), y
          iny
          lda       linnum+1
          sbc       (lowtr), y
          bcc       @LD6EC
@LD6DC:   jsr       LD6F3
          lda       (lowtr)
          tax
          ldy       #$01
          lda       (lowtr), y
          stx       lowtr
          sta       lowtr+1
          bra       @LD6C0

@LD6EC:   jsr       crdo
LD6EF:    jmp       newstt

LD6F2:    rts

LD6F3:    jsr       outspc
          ldy       #$02
          lda       (lowtr), y
          tax
          iny
          lda       (lowtr), y
          jsr       linprt
          ldy       #$03
LD703:    lda       #' '
@LD705:   jsr       outdo
          iny
          lda       #32
.ifdef    iie
          bit       $C01F
          bpl       @LD712
          lda       #72
.endif
@LD712:   cmp       $24                 ; Over the margin?
          bcs       @LD71E              ; No, skip
          jsr       crdo                ; Newline and 5 spaces
          ldx       #$05
          jsr       monspc
@LD71E:   lda       (lowtr), y
          beq       LD6F2
          bpl       @LD705
          sec
          sbc       #$7f
          tax
          jmp       LD72F
.ifdef    iie
          .res      1, $FF
.else
          .res      8, $FF
.endif

getchr:   jmp       LD60F

LD72F:    jsr       LD547
          dec       fac
          bra       @LD740

@LD736:   inc       fac
          bne       @LD73C
          inc       fac+1
@LD73C:   lda       (fac)
          bpl       @LD736
@LD740:   dex
          bne       @LD736
          jsr       outspc
@LD746:   inc       fac
          bne       @LD74C
          inc       fac+1
@LD74C:   lda       (fac)
          pha
          jsr       outdo
          pla
          bpl       @LD746
          bmi       LD703               ; ALWAYS

LD757:    pha
          lda       $f1
          beq       @LD75F
          jsr       $fca8
@LD75F:   pla
          and       #$7f
          clc
          rts

          .byte     $ff
          .byte     $ff

for:      lda       #$80
          sta       $14
          jsr       let
          jsr       fndfor
          bne       @LD777
          txa
          adc       #$0f
          tax
          txs
@LD777:   pla
          pla
          lda       #$09
          jsr       getstk
          jsr       datan
          clc
          tya
          adc       txtptr
          pha
          lda       txtptr+1
          adc       #$00
          pha
          lda       curlin+1
          pha
          lda       curlin
          pha
          lda       #$c1
          jsr       synchr
          jsr       chknum
          jsr       frmnum
          lda       $a2
          ora       #$7f
          and       fac+1
          sta       fac+1
          lda       #$af
          ldy       #$d7
          sta       index
          sty       index+1
          jmp       frm_stack_3

step:     lda       #$13
          ldy       #$e9
          jsr       load_fac_from_ya
          jsr       L00B7
          cmp       #tk_step
          bne       @LD7C3
          jsr       chrget
          jsr       frmnum
@LD7C3:   jsr       sign
          jsr       frm_stack_2
          lda       forpnt+1
          pha
          lda       forpnt
          pha
          lda       #$81
          pha
newstt:   tsx
          txa
          sta       $f8
          jsr       iscntc
          ldx       curlin+1
          lda       txtptr
          inx
          beq       @LD7E6
          sta       $79
          lda       txtptr+1
          sta       $7a
@LD7E6:   lda       (txtptr)
          bne       LD842
          clc
          lda       #$02
          tay
          lda       (txtptr), y
          beq       goend
          iny
          lda       (txtptr), y
          sta       curlin
          iny
          lda       (txtptr), y
          sta       curlin+1
          tya
          adc       txtptr
          sta       txtptr
          bcc       gone
          inc       txtptr+1
gone:     lda       curlin+1
          inc
          beq       @LD81D
          lda       $f2
          bpl       @LD81D
          lda       #$a3
          jsr       outdo
          jsr       LD8F4
          nop
          nop
          nop
          nop
          nop
          nop
          nop
@LD81D:   jsr       chrget
          jsr       execute_statement
          jmp       newstt

goend:    bra       LD88A

execute_statement:
          beq       LD857
execute_statement_1:
          sbc       #$80
          bcc       @LD83F
          cmp       #$40
          bcs       LD846
          asl
          tay
          lda       tokadr+1, y
          pha
          lda       tokadr, y
          pha
          jmp       chrget

@LD83F:   jmp       let

LD842:    cmp       #$3a
          beq       gone
LD846:    jmp       snerr

restore:  sec
          lda       txttab
          sbc       #$01
          ldy       txttab+1
          bcs       setda
          dey
setda:    sta       $7d
          sty       $7e
LD857:    rts

iscntc:   lda       #$83
          eor       $c000
          bne       LD857
          jsr       inchr
          nop
control_c_typed:
          ldx       #$ff
          ldy       errflg
          beq       @LD86C
          jmp       handlerr

@LD86C:   cmp       #$03
stop:     bcs       end2
end:      clc
end2:     bne       LD8AF
          lda       curlin+1
          inc
          beq       @LD888
          ldy       txtptr
          sty       $79
          ldy       txtptr+1
          sty       $7a
          lda       curlin
          ldy       curlin+1
          sta       $77
          sty       $78
@LD888:   pla
          pla
LD88A:    lda       #$5d
          ldy       #$d3
          bcc       @LD893
          jmp       errfin

@LD893:   jmp       ready

cont:     bne       LD8AF               ; Make sure there is a terminator.
          ldx       #e_cn
          ldy       $7a                 ; A stored TXTPTR of 0 is set up by
                                        ; STKINI and indicates there is
                                        ; nothing to continue.
          bne       @LD8A1              ; STOP, END, typing CRLF to INPUT, and
          jmp       error               ; ^C setup OLDTXT.

@LD8A1:   lda       $79
          sta       txtptr
          sty       txtptr+1
          lda       $77
          ldy       $78
          sta       curlin
          sty       curlin+1
LD8AF:    rts

LD8B0:    jsr       outqst
          jmp       inlin

cqinln:   jsr       getlin              ; Request line from monitor
          cpx       #$EF                ; Cap input line length to 239
          bcc       LD8BF
          ldx       #$EF
LD8BF:    stz       inpbuf, x
          txa
          beq       @LD8D0
@LD8C5:   lda       $01FF, x
          asl
          lsr
          sta       $01FF, x
          dex
          bne       @LD8C5
@LD8D0:   txa
          dex
          tay
          iny
          rts

LD8D5:    jsr       conint
          jsr       $fb1e
          jmp       sngflt

LD8DE:    ldx       $ac
          beq       @LD8E4
          cpx       #$02
@LD8E4:   rts

LD8E5:    jmp       frmnum

LD8E8:    bit       $14
          bmi       @LD8EE
          bvs       @LD8EF
@LD8EE:   rts

@LD8EF:   pla
          pla
          jmp       array

LD8F4:    lda       curlin+1
          ldx       curlin
          jsr       linprt
          jmp       outspc

LD8FE:    bne       @LD903
          jmp       resperr

@LD903:   jmp       input_data

.ifdef    iie
LD906:    lda       #23
          bit       $c01f
          bpl       @LD90F
          lda       #63
@LD90F:   rts

          nop
          nop
.else
          .res      12, $EA
.endif

run:      php
          dec       curlin+1
          plp
          bne       @1
          jmp       runc
@1:       jsr       clearc
          jmp       go_to_line

gosub:    lda       #$03
          jsr       getstk
          lda       txtptr+1
          pha
          lda       txtptr
          pha
          lda       curlin+1
          pha
          lda       curlin
          pha
          lda       #$b0
          pha
go_to_line:
          jsr       L00B7
          jsr       goto
          jmp       newstt

goto:     jsr       linget
          jsr       remn
          lda       curlin+1
          cmp       linnum+1
          bcs       @LD955
          tya
          sec
          adc       txtptr
          ldx       txtptr+1
          bcc       @LD959
          inx
          bcs       @LD959

@LD955:   lda       txttab
          ldx       txttab+1
@LD959:   jsr       LD61E
          bcc       userr
LD95E:    lda       lowtr
          sbc       #$01
          sta       txtptr
          lda       lowtr+1
          sbc       #$00
          sta       txtptr+1
LD96A:    rts

pop:      bne       LD96A               ; No terminator = blow him up
          lda       #$FF
          sta       forpnt+1            ; Make sure the variable's pointer
                                        ; never gets matched.
          jsr       fndfor              ; Go past all the FOR entries.
          txs
          cmp       #tk_gosub           ; RETURN without GOSUB?
          beq       return
          ldx       #e_rg
          .byte     $2C
userr:    ldx       #e_ul               ; No; Undefined Statement
          jmp       error

snerr2:   jmp       snerr

return:   pla
          pla
          cpy       #$62
          bne       pull3
          sta       curlin
          pla
          sta       curlin+1
          pla
          sta       txtptr
          pla
          sta       txtptr+1
data:     jsr       datan
addon:    tya
          clc
          adc       txtptr
          sta       txtptr
          bcc       LD9A2
          inc       txtptr+1
LD9A2:    rts

; ----------------------------------------------------------------------------
; A DATA statement is ignored, but may be terminated with :
; A REM statement is ignored, and always extends to the end of the line.
; ----------------------------------------------------------------------------

datan:    ldx       #':'
          .byte     $2C
remn:     ldx       #$00
          stx       $0d
          ldy       #$00
          sty       $0e
@LD9AE:   lda       $0e
          ldx       $0d
          sta       $0d
          stx       $0e
@LD9B6:   lda       (txtptr), y
          beq       LD9A2
          cmp       $0e
          beq       LD9A2
          iny
          cmp       #$22
          bne       @LD9B6
          beq       @LD9AE

pull3:    plx
          plx
          ply
          rts

if:       jsr       frmevl
          jsr       L00B7
          cmp       #$ab
          beq       @LD9D8
          lda       #$c4
          jsr       synchr
@LD9D8:   lda       fac
          bne       LD9E1
rem:      jsr       remn
          beq       addon
LD9E1:    jsr       L00B7
          bcs       @LD9E9
          jmp       goto

@LD9E9:   jmp       execute_statement

ongoto:   jsr       getbyt
          pha
          cmp       #tk_gosub
          beq       LD9F8
LD9F4:    cmp       #tk_goto
          bne       snerr2
LD9F8:    dec       $a1
          bne       @LDA00
          pla
          jmp       execute_statement_1

@LDA00:   jsr       chrget
          jsr       linget
          cmp       #$2C
          beq       LD9F8
          pla
LDA0B:    rts

linget:   ldx       #$00
          stx       linnum
          stx       linnum+1
@LDA12:   bcs       LDA0B
          sbc       #$2f
          sta       $0d
          lda       linnum+1
          sta       index
          cmp       #$19
          bcs       LD9F4
          lda       linnum
          asl
          rol       index
          asl
          rol       index
          adc       linnum
          sta       linnum
          lda       index
          adc       linnum+1
          sta       linnum+1
          asl       linnum
          rol       linnum+1
          lda       linnum
          adc       $0d
          sta       linnum
          bcc       @LDA40
          inc       linnum+1
@LDA40:   jsr       chrget
          jmp       @LDA12

let:      jsr       ptrget
          sta       forpnt
          sty       forpnt+1
          lda       #$d0
          jsr       synchr
          lda       $12
          pha
          lda       $11
          pha
          jsr       frmevl
          pla
          rol
          jsr       chkval
          bne       let_string
          pla
LDA63:    bpl       @LDA77
          jsr       round_fac
          jsr       ayint
          ldy       #$00
          lda       $a0
          sta       (forpnt), y
          iny
          lda       $a1
          sta       (forpnt), y
          rts

@LDA77:   jmp       setfor

let_string:
          pla
putstr:   ldy       #$02
          lda       ($a0), y
          cmp       fretop+1
          bcc       @LDA9A
          bne       @LDA8C
          dey
          lda       ($a0), y
          cmp       fretop
          bcc       @LDA9A
@LDA8C:   ldy       $a1
          cpy       vartab+1
          bcc       @LDA9A
          bne       @LDAA1
          lda       $a0
          cmp       vartab
          bcs       @LDAA1
@LDA9A:   lda       $a0
          ldy       $a1
          jmp       @LDAB7

@LDAA1:   ldy       #$00
          lda       ($a0), y
          jsr       strini
          lda       $8c
          ldy       $8d
          sta       $ab
          sty       $ac
          jsr       movins
          lda       #$9d
          ldy       #$00
@LDAB7:   sta       $8c
          sty       $8d
          jsr       fretms
          ldy       #$00
          lda       ($8c), y
          sta       (forpnt), y
          iny
          lda       ($8c), y
          sta       (forpnt), y
          iny
          lda       ($8c), y
          sta       (forpnt), y
          rts

pr_string:
          jsr       strprt
          jsr       L00B7
print:    beq       crdo
LDAD7:    beq       LDB02
          cmp       #$c0
          beq       pr_tab_or_spc
          cmp       #$c3
          clc
          beq       pr_tab_or_spc
          cmp       #$2c
          beq       pr_comma
          cmp       #$3b
          beq       pr_next_char
          nop
          jsr       frmevl
          bit       $11
          bmi       pr_string
          jsr       fout
          jsr       strlit
          bra       pr_string

          .byte     $ea

crdo:     lda       #$8d
          jsr       outdo
LDB00:    lda       #$f4
LDB02:    rts

pr_comma:
.ifdef    iie
          jsr       LD906
.else
          lda       #23
          nop
.endif
          sbc       $24
          bcc       LDB34
          lda       #$0f
          tsb       $24
          inc       $24
          bra       pr_next_char

pr_tab_or_spc:
          php
          jsr       gtbytc
          cmp       #$29
          bne       LDB83
          plp
          txa
          bcc       @LDB2A
          dec
          sbc       $24
          bcc       pr_next_char
          tax
          bra       @LDB2A

@LDB26:   jsr       outspc
          dex
@LDB2A:   bne       @LDB26
          nop
          nop
          nop
pr_next_char:
          jsr       chrget
          bra       LDAD7

LDB34:    jsr       crdo
          jmp       pr_next_char

strout:   jsr       strlit
strprt:   jsr       frefac
          tax
          ldy       #$00
          inx
@LDB44:   dex
          beq       LDB02
          lda       (index), y
          jsr       outdo
          iny
          cmp       #$0d
          bne       @LDB44
          jsr       LDB00
          jmp       @LDB44

outspc:   lda       #' '
          .byte     $2C
outqst:   lda       #'?'
outdo:    bit       #$60
          beq       @LDB68
          bit       $32
          bmi       @LDB68
          bvc       @LDB68
          ora       #$40
@LDB68:   ora       #$80
          jsr       putch
          jmp       LD757

          .byte     $ea

inputerr:
          lda       inpflg
          beq       resperr
          bmi       readerr
          ldy       #$ff
          bne       erlin

readerr:  lda       $7b
          ldy       $7c
erlin:    sta       curlin
          sty       curlin+1
LDB83:    jmp       snerr

          .byte     $ff

resperr:  ldx       #$fe                ; If ONERR is set, raise error 254.
          lda       errflg
          bpl       @1
          jmp       handlerr
@1:       lda       #<m_reent           ; Otherwise, write ?REENTER
          ldy       #>m_reent
          jsr       strout
          lda       $79
          ldy       $7a
          sta       txtptr
          sty       txtptr+1
          rts

get:      jsr       errdir
          ldx       #<(inpbuf+1)
          ldy       #>(inpbuf+1)
          lda       #$00
          sta       inpbuf+1
          lda       #$40
          bne       process_input_list  ; ALWAYS

          nop
          nop

input:    cmp       #$22
          bne       @LDBC4
          jsr       strtxt
          lda       #$3b
          jsr       synchr
          jsr       strprt
          bra       @LDBC7

          .byte     $ea

@LDBC4:   jsr       outqst
@LDBC7:   jsr       errdir
          lda       #$2c
          sta       $01ff
          jsr       inlin
          lda       #$03
          cmp       inpbuf
          bne       input_flag_zero
          jmp       control_c_typed

nxin:     jmp       LD8B0

          nop
          nop
          nop
read:     ldy       $7e
          lda       #$98
          ldx       $7d
          .byte     $cd
input_flag_zero:
          lda       #$00
process_input_list:
          sta       inpflg
          stx       $7f
          sty       $80
process_input_item:
          jsr       ptrget
          sta       forpnt
          sty       forpnt+1
          lda       txtptr
          ldy       txtptr+1
          sta       $87
          sty       $88
          ldx       $7f
          ldy       $80
          stx       txtptr
          sty       txtptr+1
          jsr       L00B7
          bne       instart
          bit       inpflg
          bvc       @LDC1F
          jsr       getch
          ldx       #$ff
          ldy       #$01
          and       #$7f
          sta       inpbuf
          bra       @LDC27

@LDC1F:   bmi       findata
          jsr       outqst
          jsr       nxin
@LDC27:   stx       txtptr
          sty       txtptr+1
instart:  jsr       chrget
          bit       $11
          bpl       @LDC63
          bit       inpflg
          bvc       @LDC3F
          inx
          stx       txtptr
          lda       #$00
          sta       $0d
          beq       @LDC4B

@LDC3F:   sta       $0d
          cmp       #$22
          beq       @LDC4C
          lda       #$3a
          sta       $0d
          lda       #$2c
@LDC4B:   clc
@LDC4C:   sta       $0e
          lda       txtptr
          ldy       txtptr+1
          adc       #$00
          bcc       @LDC57
          iny
@LDC57:   jsr       LE3ED
          jsr       point
          jsr       putstr
          jmp       input_more

@LDC63:   ldx       inpbuf
          bne       input_data
          beq       inpfin

input_data:
          jsr       fin
          lda       $12
          jsr       LDA63
input_more:
          jsr       L00B7
          beq       @LDC7E
          cmp       #$2c
          beq       @LDC7E
          jmp       inputerr

@LDC7E:   lda       txtptr
          ldy       txtptr+1
          sta       $7f
          sty       $80
          lda       $87
          ldy       $88
          sta       txtptr
          sty       txtptr+1
          jsr       L00B7
          beq       inpdone
          jsr       chkcom
          jmp       process_input_item

inpfin:   ldy       inpflg
          jmp       LD8FE

          .byte     $ea
          .byte     $ea

findata:  jsr       datan
          iny
          tax
          bne       @LDCB9
          ldx       #$2a
          iny
          lda       (txtptr), y
          beq       gerr
          iny
          lda       (txtptr), y
          sta       $7b
          iny
          lda       (txtptr), y
          iny
          sta       $7c
@LDCB9:   lda       (txtptr), y
          tax
          jsr       addon
          cpx       #$83
          bne       findata
          jmp       instart

inpdone:  lda       $7f
          ldy       $80
          ldx       inpflg
          bpl       @LDCD1
          jmp       setda

@LDCD1:   ldy       #$00
          lda       ($7f), y
          beq       @LDCDE
          lda       #$df
          ldy       #$dc
          jmp       strout

@LDCDE:   rts

m_xtra:   .byte     "?EXTRA IGNORED", 13, 0
m_reent:  .byte     "?REENTER", 13, 0

next:     bne       LDCFF
          ldy       #$00
          beq       LDD02

LDCFF:    jsr       ptrget
LDD02:    sta       forpnt
          sty       forpnt+1
          jsr       fndfor
          beq       LDD0F
          ldx       #$00
gerr:     beq       jerror

LDD0F:    txs
          txa
          clc
          adc       #$04
          pha
          adc       #$06
          sta       dest
          tax
          pla
          bra       @LDD1D

@LDD1D:   ldy       #$01
          jsr       load_fac_from_ya
          tsx
          lda       $0109, x
          sta       $a2
          lda       forpnt
          ldy       forpnt+1
          jsr       fadd
          jsr       setfor
          ldy       #$01
          jsr       fcomp2
          tsx
          sec
          sbc       $0109, x
          beq       @LDD55
          lda       $010f, x
          sta       curlin
          lda       $0110, x
          sta       curlin+1
          lda       $0112, x
          sta       txtptr
          lda       $0111, x
          sta       txtptr+1
@LDD52:   jmp       newstt

@LDD55:   txa
          adc       #$11
          tax
          txs
          jsr       L00B7
          cmp       #$2c
          bne       @LDD52
          jsr       chrget
          jsr       LDCFF
frmnum:   jsr       frmevl
chknum:   clc
          .byte     $24
chkstr:   sec
chkval:   bit       $11
          bmi       @LDD74
          bcs       @LDD76
@LDD73:   rts

@LDD74:   bcs       @LDD73
@LDD76:   ldx       #e_tm
jerror:   jmp       error

frmevl:   ldx       txtptr
          bne       @LDD81
          dec       txtptr+1
@LDD81:   dec       txtptr
          ldx       #$00
          .byte     $24
LDD86:    pha
          txa
          pha
          lda       #$01
          jsr       getstk
          jsr       frm_element
          lda       #$00
          sta       $89
LDD95:    jsr       L00B7
@LDD98:   sec
          sbc       #$cf
          bcc       @LDDB4
          cmp       #$03
          bcs       @LDDB4
          cmp       #$01
          rol
          eor       #$01
          eor       $89
          cmp       $89
          bcc       sntxerr
          sta       $89
          jsr       chrget
          jmp       @LDD98

@LDDB4:   ldx       $89
          bne       frm_relational
          bcs       notmath
          adc       #$07
          bcc       notmath
          adc       $11
          bne       @LDDC5
          jmp       cat

@LDDC5:   adc       #$ff
          sta       index
          asl
          adc       index
          tay
frm_precedence_test:
          pla
          cmp       mathtbl, y
          bcs       frm_perform_1
          jsr       chknum
nxop:     pha
savop:    jsr       frm_recurse
          pla
          ldy       $87
          bpl       prefnc
          tax
          beq       goex
          bne       frm_perform_2

frm_relational:
          lsr       $11
          txa
          rol
          ldx       txtptr
          bne       @LDDEE
          dec       txtptr+1
@LDDEE:   dec       txtptr
          ldy       #$1b
          sta       $89
          bne       frm_precedence_test

prefnc:   cmp       mathtbl, y
          bcs       frm_perform_2
          bcc       nxop

frm_recurse:
          lda       mathtbl+2, y
          pha
          lda       mathtbl+1, y
          pha
          jsr       frm_stack_1
          lda       $89
          jmp       LDD86

sntxerr:  jmp       snerr

frm_stack_1:
          lda       $a2
          ldx       mathtbl, y
frm_stack_2:
          nop
          ply
          iny
          sty       index
          ply
          sty       index+1
          nop
          nop
          pha
frm_stack_3:
          jsr       round_fac
          lda       $a1
          pha
          lda       $a0
          pha
          lda       $9f
          pha
          lda       fac+1
          pha
          lda       fac
          pha
          jmp       ($005e)

notmath:  ldy       #$ff
          pla
goex:     beq       exit
frm_perform_1:
          cmp       #$64
          beq       @LDE41
          jsr       chknum
@LDE41:   sty       $87
frm_perform_2:
          pla
          lsr
          sta       $16
          pla
          sta       $a5
          pla
          sta       $a6
          pla
          sta       $a7
          pla
          sta       $a8
          pla
          sta       $a9
          pla
          sta       $aa
          eor       $a2
          sta       $ab
exit:     lda       fac
          rts

frm_element:
          lda       #$00
          sta       $11
@LDE64:   jsr       chrget
          bcs       @LDE6C
@LDE69:   jmp       fin

@LDE6C:   jsr       isletc
          bcs       frm_variable
          cmp       #$2e
          beq       @LDE69
          cmp       #$c9
          beq       min
          cmp       #$c8
          beq       @LDE64
          cmp       #$22
          bne       do_not
strtxt:   lda       txtptr
          ldy       txtptr+1
          adc       #$00
          bcc       @LDE8A
          iny
@LDE8A:   jsr       strlit
          jmp       point

do_not:   cmp       #$c6
          bne       fn
          ldy       #$18
          bne       equl

equop:    ldy       #$00
          lda       fac
          bne       @LDE9F
          iny
@LDE9F:   jmp       sngflt

          .byte     $ea
          .byte     $ea

fn:       cmp       #$c2
          bne       sgn_
          jmp       funct

sgn_:     cmp       #$d2
          bcc       parchk
          jmp       unary

parchk:   jsr       chkopn
          jsr       frmevl
chkcls:   lda       #$29
          .byte     $2C
chkopn:   lda       #$28
          .byte     $2C
chkcom:   lda       #$2c
synchr:   ldy       #$00
          cmp       (txtptr), y
          bne       snerr
          jmp       chrget

snerr:    ldx       #e_sn
          jmp       error

min:      ldy       #$15
equl:     pla
          pla
          jmp       savop

frm_variable:
          jsr       ptrget
          sta       $a0
          sty       $a1
          ldx       $11
          beq       @LDEE5
          ldx       #$00
          stx       $ac
          rts

@LDEE5:   ldx       $12
          bpl       @LDEF6
          ldy       #$00
          lda       ($a0), y
          tax
          iny
          lda       ($a0), y
          tay
          txa
          jmp       givayf

@LDEF6:   jmp       load_fac_from_ya

scrn:     jsr       chrget
          jsr       plotfns
          jsr       $f871
          tay
          nop
          jsr       sngflt
          bra       chkcls

          .byte     $ff
          .byte     $ff
          .byte     $ff

unary:    cmp       #$d7
          beq       scrn
          asl
          pha
          tax
          jsr       chrget
          cpx       #$cf
          bcc       @LDF3A
          jsr       chkopn
          jsr       frmevl
          jsr       chkcom
          jsr       chkstr
          pla
          tax
          lda       $a1
          pha
          lda       $a0
          pha
          txa
          pha
          jsr       getbyt
          pla
          tay
          txa
          pha
          jmp       @LDF3F

@LDF3A:   jsr       parchk
          pla
          tay
@LDF3F:   lda       $cfdc, y
          sta       $91
          lda       $cfdd, y
          sta       $92
          jsr       $0090
          jmp       chknum

or:       lda       fac
          ora       $a5
          bne       true
do_and:   ldx       fac
          beq       false
          ldx       $a5
          bne       true
false:    ldy       #$00
          .byte     $ae
true:     ldy       #$01
          jmp       sngflt

relops:   jsr       chkval
          bcs       strcmp
          lda       $aa
          ora       #$7f
          and       $a6
          sta       $a6
          lda       #$a5
          ldy       #$00
          jsr       fcomp
          tax
          jmp       numcmp

strcmp:   lda       #$00
          sta       $11
          dec       $89
          jsr       frefac
          sta       fac
          stx       fac+1
          sty       $9f
          lda       $a8
          ldy       $a9
          jsr       fretmp
          stx       $a8
          sty       $a9
          tax
          sec
          sbc       fac
          beq       @LDFA5
          lda       #$01
          bcc       @LDFA5
          ldx       fac
          lda       #$ff
@LDFA5:   sta       $a2
          ldy       #$ff
          inx
LDFAA:    iny
          dex
          bne       strcmp_2
          ldx       $a2
numcmp:   bmi       cmpdone
          clc
          bcc       cmpdone

strcmp_2:
          lda       ($a8), y
          cmp       (fac+1), y
          beq       LDFAA
          ldx       #$ff
          bcs       cmpdone
          ldx       #$01
cmpdone:  inx
          txa
          rol
          and       $16
          beq       @LDFCA
          lda       #$01
@LDFCA:   jmp       float

pdl:      jmp       LD8D5

          .byte     $ea
          .byte     $ea
          .byte     $ea
          .byte     $ea
          .byte     $ea
          .byte     $ea

nxdim:    jsr       chkcom
dim:      tax
          jsr       LDFE8
          jsr       L00B7
          bne       nxdim
          rts

ptrget:   ldx       #$00
          jsr       L00B7
LDFE8:    stx       $10
LDFEA:    sta       $81
          jsr       L00B7
          jsr       isletc
          bcs       namok
badnam:   jmp       snerr

namok:    ldx       #$00
          stx       $11
          stx       $12
          bra       LE006

          .byte     $ea

bascold:  jmp       cold_start

baswarm:  jmp       ready

LE006:    nop
          jsr       chrget
          bcc       @LE011
          jsr       isletc
          bcc       @LE01C
@LE011:   tax
@LE012:   jsr       chrget
          bcc       @LE012
          jsr       isletc
          bcs       @LE012
@LE01C:   cmp       #$24
          bne       @LE026
          lda       #$ff
          sta       $11
          bne       @LE036

@LE026:   cmp       #$25
          bne       @LE03D
          lda       $14
          bmi       badnam
          lda       #$80
          sta       $12
          ora       $81
          sta       $81
@LE036:   txa
          ora       #$80
          tax
          jsr       chrget
@LE03D:   stx       $82
          sec
          ora       $14
          sbc       #$28
          bne       @LE049
          jmp       array

@LE049:   jsr       LD8E8
          nop
          nop
          nop
          lda       #$00
          sta       $14
          lda       vartab
          ldx       vartab+1
          ldy       #$00
@LE059:   stx       lowtr+1
@LE05B:   sta       lowtr
          cpx       $6c
          bne       @LE065
          cmp       $6b
          beq       name_not_found
@LE065:   lda       $81
          cmp       (lowtr), y
          bne       @LE073
          lda       $82
          iny
          cmp       (lowtr), y
          beq       set_varpnt_and_ya
          dey
@LE073:   clc
          lda       lowtr
          adc       #$07
          bcc       @LE05B
          inx
          bne       @LE059
isletc:   cmp       #$41
          bcc       @LE086
          sbc       #$5b
          sec
          sbc       #$a5
@LE086:   rts

name_not_found:
          pla
          pha
          cmp       #$d7
          bne       make_new_variable
          tsx
          lda       stack+2, x
          cmp       #$de
          bne       make_new_variable
          lda       #$66
          ldy       #$ee
          rts

          .byte     $ff
          .byte     $ff

make_new_variable:
          lda       $6b
          ldy       $6c
          sta       lowtr
LE0A2:    sty       lowtr+1
          lda       strend
          ldy       strend+1
          sta       hightr
          sty       hightr+1
          clc
          adc       #$07
          bcc       @LE0B2
          iny
@LE0B2:   sta       highds
          sty       highds+1
          jsr       bltu
          lda       highds
          ldy       highds+1
          iny
          sta       $6b
          sty       $6c
          ldy       #$00
          lda       $81
          sta       (lowtr), y
          iny
          lda       $82
          sta       (lowtr), y
          lda       #$00
          iny
          sta       (lowtr), y
          iny
          sta       (lowtr), y
          iny
          sta       (lowtr), y
          iny
          sta       (lowtr), y
          iny
          sta       (lowtr), y
set_varpnt_and_ya:
          lda       lowtr
          clc
          adc       #$02
          ldy       lowtr+1
          bcc       @LE0E8
          iny
@LE0E8:   sta       $83
          sty       $84
          rts

getary:   lda       count
          asl
          adc       #$05
          adc       lowtr
          ldy       lowtr+1
          bcc       @LE0F9
          iny
@LE0F9:   sta       highds
          sty       highds+1
          rts

neg32768:
          .byte     $90
          .byte     $80
          .byte     $00
          .byte     $00

makint:   jsr       chrget
          jsr       LD8E5
mkint:    lda       $a2
          bmi       mi1
ayint:    lda       fac
          cmp       #$90
          bcc       mi2
          lda       #$fe
          ldy       #$e0
          jsr       fcomp
mi1:      bne       iqerr
mi2:      jmp       qint

array:    ldy       $14
          bne       @LE169
          lda       $10
          ora       $12
          pha
          lda       $11
          pha
          ldy       #$00
@LE12C:   tya
          pha
          lda       $82
          pha
          lda       $81
          pha
          jsr       makint
          pla
          sta       $81
          pla
          sta       $82
          pla
          tay
          tsx
          lda       stack+2, x
          pha
          lda       stack+1, x
          pha
          lda       $a0
          sta       stack+2, x
          lda       $a1
          sta       stack+1, x
          iny
          jsr       L00B7
          cmp       #$2c
          beq       @LE12C
          sty       count
          jsr       chkcls
          pla
          sta       $11
          pla
          sta       $12
          and       #$7f
          sta       $10
@LE169:   ldx       $6b
          lda       $6c
@LE16D:   stx       lowtr
          sta       lowtr+1
          cmp       strend+1
          bne       @LE179
          cpx       strend
          beq       make_new_array
@LE179:   ldy       #$00
          lda       (lowtr), y
          iny
          cmp       $81
          bne       @LE188
          lda       $82
          cmp       (lowtr), y
          beq       use_old_array
@LE188:   iny
          lda       (lowtr), y
          clc
          adc       lowtr
          tax
          iny
          lda       (lowtr), y
          adc       lowtr+1
          bcc       @LE16D
suberr:   ldx       #e_bs
          .byte     $2C
iqerr:    ldx       #e_fc
jer:      jmp       error

use_old_array:
          ldx       #$78
          lda       $10
          bne       jer
          ldx       $14
          beq       @LE1AA
          sec
          rts

@LE1AA:   jsr       getary
          lda       count
          ldy       #$04
          cmp       (lowtr), y
          bne       suberr
          jmp       find_array_element

make_new_array:
          ldx       $14
          beq       @LE1C1
          nop
          ldx       #$2a
          bra       jer

@LE1C1:   jsr       getary
          jsr       reason
          lda       #$00
          tay
          sta       $ae
          ldx       #$05
          lda       $81
          sta       (lowtr), y
          bpl       @LE1D5
          dex
@LE1D5:   iny
          lda       $82
          sta       (lowtr), y
          bpl       @LE1DE
          dex
          dex
@LE1DE:   stx       $ad
          lda       count
          iny
          iny
          iny
          sta       (lowtr), y
@LE1E7:   ldx       #$0b
          lda       #$00
          bit       $10
          bvc       @LE1F7
          pla
          clc
          adc       #$01
          tax
          pla
          adc       #$00
@LE1F7:   iny
          sta       (lowtr), y
          iny
          txa
          sta       (lowtr), y
          jsr       multiply_subscript
          stx       $ad
          sta       $ae
          ldy       index
          dec       count
          bne       @LE1E7
          adc       highds+1
          bcs       gme
          sta       highds+1
          tay
          txa
          adc       highds
          bcc       @LE21A
          iny
          beq       gme
@LE21A:   jsr       reason
          sta       strend
          sty       strend+1
          lda       #$00
          inc       $ae
          ldy       $ad
          beq       @LE22E
@LE229:   dey
          sta       (highds), y
          bne       @LE229
@LE22E:   dec       highds+1
          dec       $ae
          bne       @LE229
          inc       highds+1
          sec
          lda       strend
          sbc       lowtr
          ldy       #$02
          sta       (lowtr), y
          lda       strend+1
          iny
          sbc       lowtr+1
          sta       (lowtr), y
          lda       $10
          bne       LE2AC
          iny
find_array_element:
          lda       (lowtr), y
          sta       count
          lda       #$00
          sta       $ad
LE253:    sta       $ae
          iny
          pla
          tax
          sta       $a0
          pla
          sta       $a1
          cmp       (lowtr), y
          bcc       LE26F
          bne       gse
          iny
          txa
          cmp       (lowtr), y
          bcc       LE270
gse:      jmp       suberr

gme:      jmp       omerr

LE26F:    iny
LE270:    lda       $ae
          ora       $ad
          clc
          beq       @LE281
          jsr       multiply_subscript
          txa
          adc       $a0
          tax
          tya
          ldy       index
@LE281:   adc       $a1
          stx       $ad
          dec       count
          bne       LE253
          sta       $ae
          ldx       #$05
          lda       $81
          bpl       @LE292
          dex
@LE292:   lda       $82
          bpl       @LE298
          dex
          dex
@LE298:   stx       $64
          lda       #$00
          jsr       LE2B6
          txa
          adc       highds
          sta       $83
          tya
          adc       highds+1
          sta       $84
          tay
          lda       $83
LE2AC:    rts

multiply_subscript:
          sty       index
          lda       (lowtr), y
          sta       $64
          dey
          lda       (lowtr), y
LE2B6:    sta       $65
          lda       #$10
          sta       $99
          ldx       #$00
          ldy       #$00
@LE2C0:   txa
          asl
          tax
          tya
          rol
          tay
          bcs       gme
          asl       $ad
          rol       $ae
          bcc       @LE2D9
          clc
          txa
          adc       $64
          tax
          tya
          adc       $65
          tay
          bcs       gme
@LE2D9:   dec       $99
          bne       @LE2C0
          rts

fre:      lda       $11
          beq       @LE2E5
          jsr       frefac
@LE2E5:   jsr       garba2
          sec
          lda       fretop
          sbc       strend
          tay
          lda       fretop+1
          sbc       strend+1
givayf:   ldx       #$00
          stx       $11
          sta       fac+1
          sty       $9f
          ldx       #$90
          jmp       float_1

pos:      ldy       $24
sngflt:   lda       #$80
          asl
          beq       givayf
errdir:   ldx       curlin+1
          inx
          bne       LE2AC
          ldx       #$95
          .byte     $2C
undfnc:   ldx       #e_uf
          jmp       error

def:      jsr       fnc
          jsr       errdir
          jsr       chkopn
          lda       #$80
          sta       $14
          jsr       ptrget
          jsr       chknum
          jsr       chkcls
          lda       #$d0
          jsr       synchr
          pha
          lda       $84
          pha
          lda       $83
          pha
          lda       txtptr+1
          pha
          lda       txtptr
          pha
          jsr       data
          jmp       fncdata

fnc:      lda       #$c2
          jsr       synchr
          ora       #$80
          sta       $14
          jsr       LDFEA
          sta       $8a
          sty       $8b
          jmp       chknum

funct:    jsr       fnc
          lda       $8b
          pha
          lda       $8a
          pha
          jsr       parchk
          jsr       chknum
          pla
          sta       $8a
          pla
          sta       $8b
          ldy       #$02
          lda       ($8a), y
          sta       $83
          tax
          iny
          lda       ($8a), y
          beq       undfnc
          sta       $84
          iny
@LE378:   lda       ($83), y
          pha
          dey
          bpl       @LE378
          ldy       $84
          jsr       store_fac_at_yx_rounded
          lda       txtptr+1
          pha
          lda       txtptr
          pha
          lda       ($8a), y
          sta       txtptr
          iny
          lda       ($8a), y
          sta       txtptr+1
          lda       $84
          pha
          lda       $83
          pha
          jsr       frmnum
          pla
          sta       $8a
          pla
          sta       $8b
          jsr       L00B7
          beq       @LE3A9
          jmp       snerr

@LE3A9:   pla
          sta       txtptr
          pla
          sta       txtptr+1
fncdata:  ldy       #$00
          pla
          sta       ($8a), y
          pla
          iny
          sta       ($8a), y
          pla
          iny
          sta       ($8a), y
          pla
          iny
          sta       ($8a), y
          pla
          iny
          sta       ($8a), y
          rts

str:      jsr       chknum
          ldy       #$00
          jsr       fout_1
          pla
          pla
          lda       #$ff
          ldy       #$00
          beq       strlit

strini:   ldx       $a0
          ldy       $a1
          stx       $8c
          sty       $8d
strspa:   jsr       getspa
          stx       fac+1
          sty       $9f
          sta       fac
          rts

strlit:   ldx       #$22
          stx       $0d
          stx       $0e
LE3ED:    sta       $ab
          sty       $ac
          sta       fac+1
          sty       $9f
          ldy       #$ff
@LE3F7:   iny
          lda       ($ab), y
          beq       @LE408
          cmp       $0d
          beq       @LE404
          cmp       $0e
          bne       @LE3F7
@LE404:   cmp       #$22
          beq       @LE409
@LE408:   clc
@LE409:   sty       fac
          tya
          adc       $ab
          sta       $ad
          ldx       $ac
          bcc       @LE415
          inx
@LE415:   stx       $ae
          jsr       LD8DE
          nop
          nop
          nop
          bne       putnew
          tya
          jsr       strini
          ldx       $ab
          ldy       $ac
          jsr       movstr
putnew:   ldx       $52
          cpx       #$5e
          bne       putemp
          ldx       #e_fc
jerr:     jmp       error

putemp:   lda       fac
          sta       $00, x
          lda       fac+1
          sta       $01, x
          lda       $9f
          sta       $02, x
          ldy       #$00
          stx       $a0
          sty       $a1
          dey
          sty       $11
          stx       $53
          inx
          inx
          inx
          stx       $52
          rts

getspa:   lsr       dores
@LE454:   pha
          eor       #$ff
          sec
          adc       fretop
          ldy       fretop+1
          bcs       @LE45F
          dey
@LE45F:   cpy       strend+1
          bcc       @LE474
          bne       @LE469
          cmp       strend
          bcc       @LE474
@LE469:   sta       fretop
          sty       fretop+1
          sta       $71
          sty       $72
          tax
          pla
          rts

@LE474:   ldx       e_om
          lda       dores
          bmi       jerr
          jsr       garba2
          lda       #$80
          sta       dores
          pla
          bne       @LE454
garba2:   ldx       memsiz
          lda       memsiz+1
find_highest_string:
          stx       fretop
          sta       fretop+1
          ldy       #$00
          sty       $8b
          lda       strend
          ldx       strend+1
          sta       lowtr
          stx       lowtr+1
          lda       #$55
          ldx       #$00
          sta       index
          stx       index+1
@LE4A0:   cmp       $52
          beq       @LE4A9
          jsr       check_variable
          beq       @LE4A0
@LE4A9:   lda       #$07
          sta       $8f
          lda       vartab
          ldx       vartab+1
          sta       index
          stx       index+1
@LE4B5:   cpx       $6c
          bne       @LE4BD
          cmp       $6b
          beq       @LE4C2
@LE4BD:   jsr       check_simple_variable
          beq       @LE4B5
@LE4C2:   sta       highds
          stx       highds+1
          lda       #$03
          sta       $8f
@LE4CA:   lda       highds
          ldx       highds+1
@LE4CE:   cpx       strend+1
          bne       @LE4D9
          cmp       strend
          bne       @LE4D9
          jmp       move_highest_string_to_top

@LE4D9:   sta       index
          stx       index+1
          ldy       #$00
          lda       (index), y
          tax
          iny
          lda       (index), y
          php
          iny
          lda       (index), y
          adc       highds
          sta       highds
          iny
          lda       (index), y
          adc       highds+1
          sta       highds+1
          plp
          bpl       @LE4CA
          txa
          bmi       @LE4CA
          iny
          lda       (index), y
          ldy       #$00
          asl
          adc       #$05
          adc       index
          sta       index
          bcc       @LE50A
          inc       index+1
@LE50A:   ldx       index+1
@LE50C:   cpx       highds+1
          bne       @LE514
          cmp       highds
          beq       @LE4CE
@LE514:   jsr       check_variable
          beq       @LE50C
check_simple_variable:
          lda       (index), y
          bmi       check_bump
          iny
          lda       (index), y
          bpl       check_bump
          iny
check_variable:
          lda       (index), y
          beq       check_bump
          iny
          lda       (index), y
          tax
          iny
          lda       (index), y
          cmp       fretop+1
          bcc       @LE538
          bne       check_bump
          cpx       fretop
          bcs       check_bump
@LE538:   cmp       lowtr+1
          bcc       check_bump
          bne       @LE542
          cpx       lowtr
          bcc       check_bump
@LE542:   stx       lowtr
          sta       lowtr+1
          lda       index
          ldx       index+1
          sta       $8a
          stx       $8b
          lda       $8f
          sta       $91
check_bump:
          lda       $8f
          clc
          adc       index
          sta       index
          bcc       check_exit
          inc       index+1
check_exit:
          ldx       index+1
          ldy       #$00
          rts

move_highest_string_to_top:
          ldy       $8b
          beq       check_exit
          lda       $91
          and       #$04
          lsr
          tay
          sta       $91
          lda       ($8a), y
          adc       lowtr
          sta       hightr
          lda       lowtr+1
          adc       #$00
          sta       hightr+1
          lda       fretop
          ldx       fretop+1
          sta       highds
          stx       highds+1
          jsr       bltuc
          ldy       $91
          iny
          lda       highds
          sta       ($8a), y
          tax
          inc       highds+1
          lda       highds+1
          iny
          sta       ($8a), y
          jmp       find_highest_string

cat:      lda       $a1
          pha
          lda       $a0
          pha
          jsr       frm_element
          jsr       chkstr
          pla
          sta       $ab
          pla
          sta       $ac
          ldy       #$00
          lda       ($ab), y
          clc
          adc       ($a0), y
          bcc       @LE5B7
          ldx       #e_ls
          jmp       error

@LE5B7:   jsr       strini
          jsr       movins
          lda       $8c
          ldy       $8d
          jsr       fretmp
          jsr       movstr_1
          lda       $ab
          ldy       $ac
          jsr       fretmp
          jsr       putnew
          jmp       LDD95

movins:   ldy       #$00
          lda       ($ab), y
          pha
          iny
          lda       ($ab), y
          tax
          iny
          lda       ($ab), y
          tay
          pla
movstr:   stx       index
          sty       index+1
movstr_1:
          tay
          beq       @LE5F3
          pha
@LE5EA:   dey
          lda       (index), y
          sta       ($71), y
          tya
          bne       @LE5EA
          pla
@LE5F3:   clc
          adc       $71
          sta       $71
          bcc       @LE5FC
          inc       $72
@LE5FC:   rts

frestr:   jsr       chkstr
frefac:   lda       $a0
          ldy       $a1
fretmp:   sta       index
          sty       index+1
          jsr       fretms
          php
          ldy       #$00
          lda       (index), y
          pha
          iny
          lda       (index), y
          tax
          iny
          lda       (index), y
          tay
          pla
          plp
          bne       @LE630
          cpy       fretop+1
          bne       @LE630
          cpx       fretop
          bne       @LE630
          pha
          clc
          adc       fretop
          sta       fretop
          bcc       @LE62F
          inc       fretop+1
@LE62F:   pla
@LE630:   stx       index
          sty       index+1
          rts

fretms:   cpy       $54
          bne       @LE645
          cmp       $53
          bne       @LE645
          sta       $52
          sbc       #$03
          sta       $53
          ldy       #$00
@LE645:   rts

chrstr:   jsr       conint
          txa
          pha
          lda       #$01
          jsr       strspa
          pla
          ldy       #$00
          sta       (fac+1), y
          pla
          pla
          jmp       putnew

leftstr:  jsr       substring_setup
          cmp       ($8c), y
          tya
LE660:    bcc       @LE666
          lda       ($8c), y
          tax
          tya
@LE666:   pha
LE667:    txa
LE668:    pha
          jsr       strspa
          lda       $8c
          ldy       $8d
          jsr       fretmp
          pla
          tay
          pla
          clc
          adc       index
          sta       index
          bcc       @LE67F
          inc       index+1
@LE67F:   tya
          jsr       movstr_1
          jmp       putnew

rightstr:
          jsr       substring_setup
          clc
          sbc       ($8c), y
          eor       #$ff
          jmp       LE660

midstr:   lda       #$ff
          sta       $a1
          jsr       L00B7
          cmp       #$29
          beq       @LE6A2
          jsr       chkcom
          jsr       getbyt
@LE6A2:   jsr       substring_setup
          dex
          txa
          pha
          clc
          ldx       #$00
          sbc       ($8c), y
          bcs       LE667
          eor       #$ff
          cmp       $a1
          bcc       LE668
          lda       $a1
          bcs       LE668

substring_setup:
          jsr       chkcls
          pla
          tay
          pla
          sta       $91
          pla
          pla
          pla
          tax
          pla
          sta       $8c
          pla
          sta       $8d
          lda       $91
          pha
          tya
          pha
          ldy       #$00
          txa
          beq       LE6E8
          rts

len:      jsr       getstr
          jmp       sngflt

getstr:   jsr       frestr
          ldx       #$00
          stx       $11
          tay
          rts

asc:      jsr       getstr
LE6E8:    beq       goiq
          ldy       #$00
          lda       (index), y
          tay
          jmp       sngflt

goiq:     jmp       iqerr

gtbytc:   jsr       chrget
getbyt:   jsr       frmnum
conint:   jsr       mkint
          ldx       $a0
          bne       goiq
          ldx       $a1
          jmp       L00B7

val:      jsr       getstr
          bne       @LE70F
          jmp       zero_fac

@LE70F:   ldx       txtptr
          ldy       txtptr+1
          stx       $ad
          sty       $ae
          ldx       index
          stx       txtptr
          clc
          adc       index
          sta       dest
          ldx       index+1
          stx       txtptr+1
          bcc       @LE727
          inx
@LE727:   stx       dest+1
          ldy       #$00
          lda       (dest), y
          pha
          lda       #$00
          sta       (dest), y
          jsr       L00B7
          jsr       fin
          pla
          ldy       #$00
          sta       (dest), y
point:    ldx       $ad
          ldy       $ae
          stx       txtptr
          sty       txtptr+1
          rts

gtnum:    jsr       frmnum
          jsr       getadr
LE74C:    jsr       chkcom
LE74F:    jmp       getbyt

getadr:   lda       fac
          cmp       #$91
          bcs       goiq
          jsr       qint
          lda       $a0
          ldy       $a1
          sty       linnum
          sta       linnum+1
          rts

peek:     lda       linnum+1
          pha
          lda       linnum
          pha
          jsr       getadr
          ldy       #$00
          lda       (linnum), y
          tay
          pla
          sta       linnum
          pla
          sta       linnum+1
          jmp       sngflt

poke:     jsr       gtnum
          txa
          ldy       #$00
          sta       (linnum), y
          rts

wait:     jsr       gtnum
          stx       forpnt
          ldx       #$00
          jsr       L00B7
          beq       @LE793
          jsr       LE74C
@LE793:   stx       forpnt+1
          ldy       #$00
@LE797:   lda       (linnum), y
          eor       forpnt+1
          and       forpnt
          beq       @LE797
LE79F:    rts

faddh:    lda       #$64
          ldy       #$ee
          jmp       fadd

fsub:     jsr       load_arg_from_ya
fsubt:    lda       $a2
          eor       #$ff
          sta       $a2
          eor       $aa
          sta       $ab
          lda       fac
          jmp       faddt

fadd_1:   jsr       shift_right
          bcc       LE7FA
fadd:     jsr       load_arg_from_ya
faddt:    bne       @LE7C6
          jmp       copy_arg_to_fac

@LE7C6:   ldx       $ac
          stx       $92
          ldx       #$a5
          lda       $a5
fadd_2:   tay
          beq       LE79F
          sec
          sbc       fac
          beq       LE7FA
          bcc       @LE7EA
          sty       fac
          ldy       $aa
          sty       $a2
          eor       #$ff
          adc       #$00
          ldy       #$00
          sty       $92
          ldx       #$9d
          bne       @LE7EE

@LE7EA:   ldy       #$00
          sty       $ac
@LE7EE:   cmp       #$f9
          bmi       fadd_1
          tay
          lda       $ac
          lsr       $01, x
          jsr       LE907
LE7FA:    bit       $ab
          bpl       fadd_4
          ldy       #$9d
          cpx       #$a5
          beq       @LE806
          ldy       #$a5
@LE806:   sec
          eor       #$ff
          adc       $92
          sta       $ac
          lda       $0004, y
          sbc       $04, x
          sta       $a1
          lda       $0003, y
          sbc       $03, x
          sta       $a0
          lda       $0002, y
          sbc       $02, x
          sta       $9f
          lda       $0001, y
          sbc       $01, x
          sta       fac+1
normalize_fac_1:
          bcs       normalize_fac_2
          jsr       complement_fac
normalize_fac_2:
          ldy       #$00
          tya
          clc
@LE832:   ldx       fac+1
          bne       LE880
          ldx       $9f
          stx       fac+1
          ldx       $a0
          stx       $9f
          ldx       $a1
          stx       $a0
          ldx       $ac
          stx       $a1
          sty       $ac
          adc       #$08
          cmp       #$20
          bne       @LE832
zero_fac:
          lda       #$00
sta_in_fac_sign_and_exp:
          sta       fac
sta_in_fac_sign:
          sta       $a2
          rts

fadd_4:   adc       $92
          sta       $ac
          lda       $a1
          adc       $a9
          sta       $a1
          lda       $a0
          adc       $a8
          sta       $a0
          lda       $9f
          adc       $a7
          sta       $9f
          lda       fac+1
          adc       $a6
          sta       fac+1
          jmp       LE88D

normalize_fac_3:
          adc       #$01
          asl       $ac
          rol       $a1
          rol       $a0
          rol       $9f
          rol       fac+1
LE880:    bpl       normalize_fac_3
          sec
          sbc       fac
          bcs       zero_fac
          eor       #$ff
          adc       #$01
          sta       fac
LE88D:    bcc       LE89D
LE88F:    inc       fac
          beq       overflow
          ror       fac+1
          ror       $9f
          ror       $a0
          ror       $a1
          ror       $ac
LE89D:    rts

complement_fac:
          lda       $a2
          eor       #$ff
          sta       $a2
complement_fac_mantissa:
          lda       fac+1
          eor       #$ff
          sta       fac+1
          lda       $9f
          eor       #$ff
          sta       $9f
          lda       $a0
          eor       #$ff
          sta       $a0
          lda       $a1
          eor       #$ff
          sta       $a1
          lda       $ac
          eor       #$ff
          sta       $ac
          inc       $ac
          bne       LE8D4
increment_fac_mantissa:
          inc       $a1
          bne       LE8D4
          inc       $a0
          bne       LE8D4
          inc       $9f
          bne       LE8D4
          inc       fac+1
LE8D4:    rts

overflow:
          ldx       #e_ov
          jmp       error

shift_right_1:
          ldx       #$61
shift_right_2:
          ldy       $04, x
          sty       $ac
          ldy       $03, x
          sty       $04, x
          ldy       $02, x
          sty       $03, x
          ldy       $01, x
          sty       $02, x
          ldy       $a4
          sty       $01, x
shift_right:
          adc       #$08
          bmi       shift_right_2
          beq       shift_right_2
          sbc       #$08
          tay
          lda       $ac
          bcs       LE911
LE8FD:    asl       $01, x
          bcc       @LE903
          inc       $01, x
@LE903:   ror       $01, x
          ror       $01, x
LE907:    ror       $02, x
          ror       $03, x
          ror       $04, x
          ror
          iny
          bne       LE8FD
LE911:    clc
          rts

          .byte     $81
          .byte     $00
          .byte     $00
          .byte     $00
          .byte     $00
          .byte     $03
          .byte     $7f
          .byte     $5e
          .byte     $56
          .byte     $cb
          .byte     $79
          .byte     $80
          .byte     $13
          .byte     $9b
          .byte     $0b
          .byte     $64
          .byte     $80
          .byte     $76
          .byte     $38
          .byte     $93
          .byte     $16
          .byte     $82
          .byte     $38
          .byte     $aa
          .byte     $3b
          .byte     $20
          .byte     $80
          .byte     $35
          .byte     $04
          .byte     $f3
          .byte     $34
          .byte     $81
          .byte     $35
          .byte     $04
          .byte     $f3
          .byte     $34
          .byte     $80
          .byte     $80
          .byte     $00
          .byte     $00
          .byte     $00
          .byte     $80
          .byte     $31
          .byte     $72
          .byte     $17
          .byte     $f8

log:      jsr       sign
          beq       giq
          bpl       LE94B
giq:      jmp       iqerr

LE94B:    lda       fac
          sbc       #$7f
          pha
          lda       #$80
          sta       fac
          lda       #$2d
          ldy       #$e9
          jsr       fadd
          lda       #$32
          ldy       #$e9
          jsr       fdiv
          lda       #$13
          ldy       #$e9
          jsr       fsub
          lda       #$18
          ldy       #$e9
          jsr       polynomial_odd
          lda       #$37
          ldy       #$e9
          jsr       fadd
          pla
          jsr       addacc
          lda       #$3c
          ldy       #$e9
fmult:    jsr       load_arg_from_ya
TE982:    bne       @LE987
          jmp       LE9E2

@LE987:   jsr       add_exponents
          lda       #$00
          sta       $62
          sta       $63
          sta       $64
          sta       $65
          lda       $ac
          jsr       multiply_1
          lda       $a1
          jsr       multiply_1
          lda       $a0
          jsr       multiply_1
          lda       $9f
          jsr       multiply_1
          lda       fac+1
          jsr       multiply_2
          jmp       copy_result_into_fac

multiply_1:
          bne       multiply_2
          jmp       shift_right_1

multiply_2:
          lsr
          ora       #$80
@LE9B8:   tay
          bcc       @LE9D4
          clc
          lda       $65
          adc       $a9
          sta       $65
          lda       $64
          adc       $a8
          sta       $64
          lda       $63
          adc       $a7
          sta       $63
          lda       $62
          adc       $a6
          sta       $62
@LE9D4:   ror       $62
          ror       $63
          ror       $64
          ror       $65
          ror       $ac
          tya
          lsr
          bne       @LE9B8
LE9E2:    rts

load_arg_from_ya:
          sta       index
          sty       index+1
          ldy       #$04
          lda       (index), y
          sta       $a9
          dey
          lda       (index), y
          sta       $a8
          dey
          lda       (index), y
          sta       $a7
          dey
          lda       (index), y
          sta       $aa
          eor       $a2
          sta       $ab
          lda       $aa
          ora       #$80
          sta       $a6
          dey
          lda       (index), y
          sta       $a5
          lda       fac
          rts

add_exponents:
          lda       $a5
LEA10:    beq       zero
          clc
          adc       fac
          bcc       @LEA1B
          bmi       jov
          clc
          .byte     $2C
@LEA1B:   bpl       zero
          adc       #$80
          sta       fac
          bne       @LEA26
          jmp       sta_in_fac_sign

@LEA26:   lda       $ab
          sta       $a2
          rts

outofrng:
          lda       $a2
          eor       #$ff
          bmi       jov
zero:     pla
          pla
          jmp       zero_fac

jov:      jmp       overflow

mul10:    jsr       copy_fac_to_arg_rounded
          tax
          beq       @LEA4F
          clc
          adc       #$02
          bcs       jov
          ldx       #$00
          stx       $ab
          jsr       fadd_2
          inc       fac
          beq       jov
@LEA4F:   rts

          .byte     $84
          .byte     $20
          .byte     $00
          .byte     $00
          .byte     $00

div10:    jsr       copy_fac_to_arg_rounded
          lda       #$50
          ldy       #$ea
          ldx       #$00
div:      stx       $ab
LEA60:    jsr       load_fac_from_ya
          jmp       fdivt

fdiv:     jsr       load_arg_from_ya
fdivt:    beq       @LEAE1
          jsr       round_fac
          lda       #$00
          sec
          sbc       fac
          sta       fac
          jsr       add_exponents
          inc       fac
          beq       jov
          ldx       #$fc
          lda       #$01
@LEA80:   ldy       $a6
          cpy       fac+1
          bne       @LEA96
          ldy       $a7
          cpy       $9f
          bne       @LEA96
          ldy       $a8
          cpy       $a0
          bne       @LEA96
          ldy       $a9
          cpy       $a1
@LEA96:   php
          rol
          bcc       @LEAA3
          inx
          sta       $65, x
          beq       @LEAD1
          bpl       @LEAD5
          lda       #$01
@LEAA3:   plp
          bcs       @LEAB4
@LEAA6:   asl       $a9
          rol       $a8
          rol       $a7
          rol       $a6
          bcs       @LEA96
          bmi       @LEA80
          bpl       @LEA96

@LEAB4:   tay
          lda       $a9
          sbc       $a1
          sta       $a9
          lda       $a8
          sbc       $a0
          sta       $a8
          lda       $a7
          sbc       $9f
          sta       $a7
          lda       $a6
          sbc       fac+1
          sta       $a6
          tya
          jmp       @LEAA6

@LEAD1:   lda       #$40
          bne       @LEAA3

@LEAD5:   asl
          asl
          asl
          asl
          asl
          asl
          sta       $ac
          plp
          jmp       copy_result_into_fac

@LEAE1:   ldx       #e_dz
          jmp       error

copy_result_into_fac:
          lda       $62
          sta       fac+1
          lda       $63
          sta       $9f
          lda       $64
          sta       $a0
          lda       $65
          sta       $a1
          jmp       normalize_fac_2

load_fac_from_ya:
          sta       index
          sty       index+1
          ldy       #$04
          lda       (index), y
          sta       $a1
          dey
          lda       (index), y
          sta       $a0
          dey
          lda       (index), y
          sta       $9f
          dey
          lda       (index), y
          sta       $a2
          ora       #$80
          sta       fac+1
          dey
          lda       (index), y
          sta       fac
          sty       $ac
          rts

store_fac_in_temp2_rounded:
          ldx       #$98
          .byte     $2C
store_fac_in_temp1_rounded:
          ldx       #$93
          ldy       #$00
          beq       store_fac_at_yx_rounded

setfor:   ldx       forpnt
          ldy       forpnt+1
store_fac_at_yx_rounded:
          jsr       round_fac
          stx       index
          sty       index+1
          ldy       #$04
          lda       $a1
          sta       (index), y
          dey
          lda       $a0
          sta       (index), y
          dey
          lda       $9f
          sta       (index), y
          dey
          lda       $a2
          ora       #$7f
          and       fac+1
          sta       (index), y
          dey
          lda       fac
          sta       (index), y
          sty       $ac
          rts

copy_arg_to_fac:
          lda       $aa
LEB55:    sta       $a2
          ldx       #$05
@LEB59:   lda       $a4, x
          sta       lowtr+1, x
          dex
          bne       @LEB59
          stx       $ac
          rts

copy_fac_to_arg_rounded:
          jsr       round_fac
LEB66:    ldx       #$06
@LEB68:   lda       lowtr+1, x
          sta       $a4, x
          dex
          bne       @LEB68
          stx       $ac
LEB71:    rts

round_fac:
          lda       fac
          beq       LEB71
          asl       $ac
          bcc       LEB71
increment_mantissa:
          jsr       increment_fac_mantissa
          bne       LEB71
          jmp       LE88F

sign:     lda       fac
          beq       LEB8F
sign1:    lda       $a2
sign2:    rol
          lda       #$ff
          bcs       LEB8F
          lda       #$01
LEB8F:    rts

sgn:      jsr       sign
float:    sta       fac+1
          lda       #$00
          sta       $9f
          ldx       #$88
float_1:  lda       fac+1
          eor       #$ff
          rol
float_2:  lda       #$00
          sta       $a1
          sta       $a0
          stx       fac
          sta       $ac
          sta       $a2
          jmp       normalize_fac_1

abs:      lsr       $a2
          rts

fcomp:    sta       dest
fcomp2:   sty       dest+1
          ldy       #$00
          lda       (dest), y
          iny
          tax
          beq       sign
          lda       (dest), y
          eor       $a2
          bmi       sign1
          cpx       fac
          bne       @LEBE9
          lda       (dest), y
          ora       #$80
          cmp       fac+1
          bne       @LEBE9
          iny
          lda       (dest), y
          cmp       $9f
          bne       @LEBE9
          iny
          lda       (dest), y
          cmp       $a0
          bne       @LEBE9
          iny
          lda       #$7f
          cmp       $ac
          lda       (dest), y
          sbc       $a1
          beq       LEC11
@LEBE9:   lda       $a2
          bcc       @LEBEF
          eor       #$ff
@LEBEF:   jmp       sign2

qint:     lda       fac
          beq       qint_3
          sec
          sbc       #$a0
          bit       $a2
          bpl       @LEC06
          tax
          lda       #$ff
          sta       $a4
          jsr       complement_fac_mantissa
          txa
@LEC06:   ldx       #$9d
          cmp       #$f9
          bpl       qint_2
          jsr       shift_right
          sty       $a4
LEC11:    rts

qint_2:   tay
          lda       $a2
          and       #$80
          lsr       fac+1
          ora       fac+1
          sta       fac+1
          jsr       LE907
          sty       $a4
          rts

int:      lda       fac
          cmp       #$a0
          bcs       LEC49
          jsr       qint
          sty       $ac
          lda       $a2
          sty       $a2
          eor       #$80
          rol
          lda       #$a0
          sta       fac
          lda       $a1
          sta       $0d
          jmp       normalize_fac_1

qint_3:   sta       fac+1
          sta       $9f
          sta       $a0
          sta       $a1
          tay
LEC49:    rts

fin:      ldy       #$00
          ldx       #$0a
@LEC4E:   sty       $99, x
          dex
          bpl       @LEC4E
          bcc       LEC64
          cmp       #$2d
          bne       @LEC5D
          stx       $a3
          beq       LEC61

@LEC5D:   cmp       #$2b
          bne       LEC66
LEC61:    jsr       chrget
LEC64:    bcc       LECC1
LEC66:    cmp       #$2e
          beq       LEC98
          cmp       #$45
          bne       LEC9E
          jsr       chrget
          bcc       LEC8A
          cmp       #$c9
          beq       @LEC85
          cmp       #$2d
          beq       @LEC85
          cmp       #$c8
          beq       LEC87
          cmp       #$2b
          beq       LEC87
          bne       LEC8C

@LEC85:   ror       lowtr+1
LEC87:    jsr       chrget
LEC8A:    bcc       getexp
LEC8C:    bit       lowtr+1
          bpl       LEC9E
          lda       #$00
          sec
          sbc       $9a
          jmp       LECA0

LEC98:    ror       lowtr
          bit       lowtr
          bvc       LEC61
LEC9E:    lda       $9a
LECA0:    sec
          sbc       $99
          sta       $9a
          beq       @LECB9
          bpl       @LECB2
@LECA9:   jsr       div10
          inc       $9a
          bne       @LECA9
          beq       @LECB9

@LECB2:   jsr       mul10
          dec       $9a
          bne       @LECB2
@LECB9:   lda       $a3
          bmi       @LECBE
          rts

@LECBE:   jmp       negop

LECC1:    pha
          bit       lowtr
          bpl       @LECC8
          inc       $99
@LECC8:   jsr       mul10
          pla
          sec
          sbc       #$30
          jsr       addacc
          jmp       LEC61

addacc:   pha
          jsr       copy_fac_to_arg_rounded
          pla
          jsr       float
          lda       $aa
          eor       $a2
          sta       $ab
          ldx       fac
          jmp       faddt

getexp:   lda       $9a
          cmp       #$0a
          bcc       @LECF7
          lda       #$64
          bit       lowtr+1
          bmi       @LED05
          jmp       overflow

@LECF7:   asl
          asl
          clc
          adc       $9a
          asl
          clc
          ldy       #$00
          adc       (txtptr), y
          sec
          sbc       #$30
@LED05:   sta       $9a
          jmp       LEC87

          .byte     $9b
          .byte     $3e
          .byte     $bc
          .byte     $1f
          .byte     $fd
          .byte     $9e
          .byte     $6e
          .byte     $6b
          .byte     $27
          .byte     $fd
          .byte     $9e
          .byte     $6e
          .byte     $6b
          .byte     $28
          .byte     $00

inprt:  lda       #$58
          ldy       #$d3
          jsr       go_strout
          lda       curlin+1
          ldx       curlin
linprt:   sta       fac+1
          stx       $9f
          ldx       #$90
          sec
          jsr       float_2
          jsr       fout
go_strout:
          jmp       strout

fout:     ldy       #$01
fout_1:   bit       $a2
          bpl       @LED40
          lda       #$2d
          sta       $00ff, y
          .byte     $24
@LED40:   dey
          stz       $a2
          sty       $ad
          iny
          lda       #$30
          ldx       fac
          bne       @LED4F
          jmp       @LEE57

@LED4F:   lda       #$00
          cpx       #$80
          beq       @LED57
          bcs       @LED60
@LED57:   lda       #$14
          ldy       #$ed
          jsr       fmult
          lda       #$f7
@LED60:   sta       $99
@LED62:   lda       #$0f
          ldy       #$ed
          jsr       fcomp
          beq       @LED89
          bpl       @LED7F
@LED6D:   lda       #$0a
          ldy       #$ed
          jsr       fcomp
          beq       @LED78
          bpl       @LED86
@LED78:   jsr       mul10
          dec       $99
          bne       @LED6D
@LED7F:   jsr       div10
          inc       $99
          bne       @LED62
@LED86:   jsr       faddh
@LED89:   jsr       qint
          ldx       #$01
          lda       $99
          clc
          adc       #$0a
          bmi       @LED9E
          cmp       #$0b
          bcs       @LED9F
          adc       #$ff
          tax
          lda       #$02
@LED9E:   sec
@LED9F:   sbc       #$02
          sta       $9a
          stx       $99
          txa
          beq       @LEDAA
          bpl       @LEDBD
@LEDAA:   ldy       $ad
          lda       #$2e
          iny
          sta       $00ff, y
          txa
          beq       @LEDBB
          lda       #$30
          iny
          sta       $00ff, y
@LEDBB:   sty       $ad
@LEDBD:   ldy       #$00
          ldx       #$80
@LEDC1:   lda       $a1
          clc
          adc       @LEE6C, y
          sta       $a1
          lda       $a0
          adc       @LEE6B, y
          sta       $a0
          lda       $9f
          adc       @LEE6A, y
          sta       $9f
          lda       fac+1
          adc       @LEE69, y
          sta       fac+1
          inx
          bcs       @LEDE5
          bpl       @LEDC1
          bmi       @LEDE7

@LEDE5:   bmi       @LEDC1
@LEDE7:   txa
          bcc       @LEDEE
          eor       #$ff
          adc       #$0a
@LEDEE:   adc       #$2f
          iny
          iny
          iny
          iny
          sty       $83
          ldy       $ad
          iny
          tax
          and       #$7f
          sta       $00ff, y
          dec       $99
          bne       @LEE09
          lda       #$2e
          iny
          sta       $00ff, y
@LEE09:   sty       $ad
          ldy       $83
          txa
          eor       #$ff
          and       #$80
          tax
          cpy       #$24
          bne       @LEDC1
          ldy       $ad
@LEE19:   lda       $00ff, y
          dey
          cmp       #$30
          beq       @LEE19
          cmp       #$2e
          beq       @LEE26
          iny
@LEE26:   lda       #$2b
          ldx       $9a
          beq       @LEE5A
          bpl       @LEE36
          lda       #$00
          sec
          sbc       $9a
          tax
          lda       #$2d
@LEE36:   sta       stack+1, y
          lda       #$45
          sta       stack, y
          txa
          ldx       #$2f
          sec
@LEE42:   inx
          sbc       #$0a
          bcs       @LEE42
          adc       #$3a
          sta       stack+3, y
          txa
          sta       stack+2, y
          lda       #$00
          sta       $0104, y
          beq       @LEE5F

@LEE57:   sta       $00ff, y
@LEE5A:   lda       #$00
          sta       stack, y
@LEE5F:   lda       #$00
          ldy       #$01
          rts

          .byte     $80
          .byte     $00
          .byte     $00
          .byte     $00
          .byte     $00
@LEE69:   .byte     $fa
@LEE6A:   .byte     $0a
@LEE6B:   .byte     $1f
@LEE6C:   .byte     $00
          .byte     $00
          .byte     $98
          .byte     hightr
          .byte     $80
          .byte     $ff
          .byte     $f0
          .byte     $bd
          .byte     $c0
          .byte     $00
          .byte     $01
          .byte     $86
          .byte     $a0
          .byte     $ff
          .byte     $ff
          .byte     $d8
          .byte     $f0
          .byte     $00
          .byte     $00
          .byte     $03
          .byte     $e8
          .byte     $ff
          .byte     $ff
          .byte     $ff
          .byte     lowtr+1
          .byte     $00
          .byte     $00
          .byte     $00
          .byte     $0a
          .byte     $ff
          .byte     $ff
          .byte     $ff
          .byte     $ff

sqr:      jsr       copy_fac_to_arg_rounded
          lda       #$64
          ldy       #$ee
          jsr       load_fac_from_ya
TEE97:    beq       exp
          lda       $a5
          bne       @LEEA0
          jmp       sta_in_fac_sign_and_exp

@LEEA0:   ldx       #$8a
          ldy       #$00
          jsr       store_fac_at_yx_rounded
          lda       $aa
          bpl       @LEEBA
          jsr       int
          lda       #$8a
          ldy       #$00
          jsr       fcomp
          bne       @LEEBA
          tya
          ldy       $0d
@LEEBA:   jsr       LEB55
          tya
          pha
          jsr       log
          lda       #$8a
          ldy       #$00
          jsr       fmult
          jsr       exp
          pla
          lsr
          bcc       LEEDA
negop:    lda       fac
          beq       LEEDA
          lda       $a2
          eor       #$ff
          sta       $a2
LEEDA:    rts

          .byte     $81
          .byte     $38
          .byte     $aa
          .byte     $3b
          .byte     $29
          .byte     $07
          .byte     $71
          .byte     $34
          .byte     $58
          .byte     $3e
          .byte     $56
          .byte     $74
          .byte     $16
          .byte     $7e
          .byte     $b3
          .byte     $1b
          .byte     $77
          .byte     $2f
          .byte     $ee
          .byte     $e3
          .byte     $85
          .byte     $7a
          .byte     $1d
          .byte     $84
          .byte     $1c
          .byte     "*|cYX",$0a,"~u"
          .byte     $fd
          .byte     $e7
          .byte     $c6
          .byte     $80
          .byte     $31
          .byte     $72
          .byte     $18
          .byte     $10
          .byte     $81
          .byte     $00
          .byte     $00
          .byte     $00
          .byte     $00

exp:      lda       #$db
          ldy       #$ee
          jsr       fmult
          lda       $ac
          adc       #$50
          bcc       @LEF19
          jsr       increment_mantissa
@LEF19:   sta       $92
          jsr       LEB66
          lda       fac
          cmp       #$88
          bcc       @LEF27
@LEF24:   jsr       outofrng
@LEF27:   jsr       int
          lda       $0d
          clc
          adc       #$81
          beq       @LEF24
          sec
          sbc       #$01
          pha
          ldx       #$05
@LEF37:   lda       $a5, x
          ldy       fac, x
          sta       fac, x
          sty       $a5, x
          dex
          bpl       @LEF37
          lda       $92
          sta       $ac
          jsr       fsubt
          jsr       negop
          lda       #$e0
          ldy       #$ee
          jsr       polynomial
          lda       #$00
          sta       $ab
          pla
          jsr       LEA10
          rts

polynomial_odd:
          sta       $ad
          sty       $ae
          jsr       store_fac_in_temp1_rounded
          lda       #$93
          jsr       fmult
          jsr       sermain
          lda       #$93
          ldy       #$00
          jmp       fmult

polynomial:
          sta       $ad
          sty       $ae
sermain:  jsr       store_fac_in_temp2_rounded
          lda       ($ad), y
          sta       $a3
          ldy       $ad
          iny
          tya
          bne       @LEF85
          inc       $ae
@LEF85:   sta       $ad
          ldy       $ae
@LEF89:   jsr       fmult
          lda       $ad
          ldy       $ae
          clc
          adc       #$05
          bcc       @LEF96
          iny
@LEF96:   sta       $ad
          sty       $ae
          jsr       fadd
          lda       #$98
          ldy       #$00
          dec       $a3
          bne       @LEF89
LEFA5:    rts

          .byte     $98
          .byte     $35
          .byte     $44
          .byte     $7a
          .byte     $68
          .byte     $28
          .byte     $b1
          .byte     $46

rnd:      jsr       sign
          tax
          bmi       @LEFCC
          lda       #$c9
          ldy       #$00
          jsr       load_fac_from_ya
          txa
          beq       LEFA5
          lda       #$a6
          ldy       #$ef
          jsr       fmult
          lda       #$aa
          ldy       #$ef
          jsr       fadd
@LEFCC:   ldx       $a1
          lda       fac+1
          sta       $a1
          stx       fac+1
          lda       #$00
          sta       $a2
          lda       fac
          sta       $ac
          lda       #$80
          sta       fac
          jsr       normalize_fac_2
          ldx       #$c9
          ldy       #$00
LEFE7:    jmp       store_fac_at_yx_rounded

cos:      lda       #$66
          ldy       #$f0
          jsr       fadd
sin:      jsr       copy_fac_to_arg_rounded
          lda       #$6b
          ldy       #$f0
          ldx       $aa
          jsr       div
          jsr       copy_fac_to_arg_rounded
          jsr       int
          lda       #$00
          sta       $ab
          jsr       fsubt
          lda       #$70
          ldy       #$f0
          jsr       fsub
          lda       $a2
          pha
          bpl       sin_1
          jsr       faddh
          lda       $a2
          bmi       sin_2
          lda       $16
          eor       #$ff
          sta       $16
sin_1:    jsr       negop
sin_2:    lda       #$70
          ldy       #$f0
          jsr       fadd
          pla
          bpl       @LF033
          jsr       negop
@LF033:   lda       #$75
          ldy       #$f0
          jmp       polynomial_odd

tan:      jsr       store_fac_in_temp1_rounded
          lda       #$00
          sta       $16
          jsr       sin
          ldx       #$8a
          ldy       #$00
          jsr       LEFE7
          lda       #$93
          ldy       #$00
          jsr       load_fac_from_ya
          lda       #$00
          sta       $a2
          lda       $16
          jsr       @LF062
          lda       #$8a
          ldy       #$00
          jmp       fdiv

@LF062:   pha
          jmp       sin_1

          .byte     $81
          .byte     $49
          .byte     $0f
          .byte     $da
          .byte     $a2
          .byte     $83
          .byte     $49
          .byte     $0f
          .byte     $da
          .byte     $a2
          .byte     $7f
          .byte     $00
          .byte     $00
          .byte     $00
          .byte     $00
          .byte     $05
          .byte     $84
          .byte     $e6
          .byte     $1a
          .byte     $2d
          .byte     $1b
          .byte     $86
          .byte     $28
          .byte     $07
          .byte     $fb
          .byte     $f8
          .byte     $87
          .byte     $99
          .byte     $68
          .byte     $89
          .byte     $01
          .byte     $87
          .byte     $23
          .byte     $35
          .byte     $df
          .byte     $e1
          .byte     $86
          .byte     $a5
          .byte     $5d
          .byte     $e7
          .byte     $28
          .byte     $83
          .byte     $49
          .byte     $0f
          .byte     $da
          .byte     $a2
microsoft:
          .byte     "ANITA&PHIL"

atn:      lda       $a2
          pha
          bpl       @LF0A6
          jsr       negop
@LF0A6:   lda       fac
          pha
          cmp       #$81
          bcc       @LF0B4
          lda       #$13
          ldy       #$e9
          jsr       fdiv
@LF0B4:   lda       #$ce
          ldy       #$f0
          jsr       polynomial_odd
          pla
          cmp       #$81
          bcc       @LF0C7
          lda       #$66
          ldy       #$f0
          jsr       fsub
@LF0C7:   pla
          bpl       @LF0CD
          jmp       negop

@LF0CD:   rts

          .byte     $0b
          .byte     $76
          .byte     $b3
          .byte     $83
          .byte     $bd
          .byte     $d3
          .byte     $79
          .byte     $1e
          .byte     $f4
          .byte     $a6
          .byte     $f5
          .byte     $7b
          .byte     $83
          .byte     $fc
          .byte     $b0
          .byte     $10
          .byte     $7c
          .byte     $0c
          .byte     $1f
          .byte     $67
          .byte     $ca
          .byte     $7c
          .byte     $de
          .byte     $53
          .byte     $cb
          .byte     $c1
          .byte     $7d
          .byte     $14
          .byte     "dpL}"
          .byte     $b7
          .byte     $ea
          .byte     "Qz}c0"
          .byte     $88
          .byte     $7e
          .byte     $7e
          .byte     $92
          .byte     $44
          .byte     $99
          .byte     $3a
          .byte     $7e
          .byte     $4c
          .byte     $cc
          .byte     $91
          .byte     $c7
          .byte     $7f
          .byte     $aa
          .byte     $aa
          .byte     $aa
          .byte     $13
          .byte     $81
          .byte     $00
          .byte     $00
          .byte     $00
          .byte     $00

orgchget:
          .org      $00b1
chrget:   inc       txtptr
          bne       L00B7
          inc       txtptr+1
L00B7:    lda       LEA60               ; TXTPTR points here
          cmp       #$3a
          bcs       @L00C8
          cmp       #$20
          beq       chrget
          sec
          sbc       #$30
          sec
          sbc       #$d0
@L00C8:   rts

          .byte     $80
          .byte     $4f
          .byte     $c7
          .byte     $52
L00CD:    .byte     $58

          .org      orgchget+(*-chrget)
cold_start:
          ldx       #$ff
          stx       $32
          stx       curlin+1
          ldx       #$fb
          txs
          ldx       #$00
          stx       $01
          stx       $04
          ldx       #$e0
          stx       $02
          stx       $05
          ldx       #$4c
          stx       $90
          stx       $0a
          stx       $00
          stx       $03
          ldx       #$e1
          stx       $0c
          ldx       #$99
          stx       $0b
          ldx       #$1b
@LF151:   ldy       $f10b, x
          sty       chrget, x
          dex
          bpl       @LF151
          stz       $f2
          stz       $a4
          stz       $54
          stz       $f1
          inx
          phx
          inx
          stx       $01fd
          stx       $01fc
          stx       txttab
          inx
          inx
          stx       $8f
          jsr       crdo
          ldy       #$c0
          stz       memsiz
          sty       memsiz+1
          stz       fretop
          sty       fretop+1
          ldy       #$08
          stz       linnum
          sty       linnum+1
          sty       txttab+1
          stz       $0800
          lda       #$55
          sta       $52
          jsr       reason
          jsr       scrtch
          stz       $057b
          bra       LF1C2

LF197:    jsr       LF798
LF19A:    ldx       #$00
          jmp       ($0050,x)

LF19F:    jsr       LF7A1
LF1A2:    jmp       $fe8b

LF1A5:    jsr       LF7A1
LF1A8:    jmp       $fe95

          .res      23,$ff

LF1C2:    lda       #$3a
          ldy       #$db
          sta       $04
          sty       $05
          lda       #$3c
          ldy       #$d4
          sta       $01
          sty       $02
          jmp       ($0001)

call:     bra       LF197

          .byte     $ff

          jsr       getadr
          bra       LF19A

          .byte     $ff

in_number:
          bra       LF19F

          .byte     $ff

          phx
          pla
          bra       LF1A2

pr_number:
          bra       LF1A5

          .byte     $ff

          phx
          pla
          bra       LF1A8

plotfns:  jsr       LF7A7
          pha
          jsr       chkcom
          jsr       LF7AA
          ply
          rts

          .res      5,$ff

          stx       $2d
          stx       $2c
          rts

          .byte     $ff
          .byte     $ff
          .byte     $ff
          .byte     $ff

          jmp       iqerr

          .res      23,$ff

          rts

          .byte     $ff
          .byte     $ff
          .byte     $ff
          .byte     $ff

plot:     jmp       LF23B

          ldy       $f0
          txa
          jmp       $f800

          .byte     $ff
          .byte     $ff
          .byte     $ff
          .byte     $ff

hlin:     jmp       LF612

          ldy       $f0
          txa
          jmp       $f819

LF23B:    jsr       plotfns
          jmp       $f800

vlin:     jmp       LF631

          lda       $f0
          phx
          ply
          jmp       $f828

LF24B:    jmp       $f864

          .byte     $ff

color:    jsr       LF7BF
          phx
          pla
          bra       LF24B

fpvtab:   jsr       LF79E
          phx
          pla
          dec
          bmi       LF2BE
          jmp       $fb5b

          .byte     $ff

speed:    jsr       LE74F
          phx
          pla
          eor       #$ff
          sta       $f1
          rts

          .byte     $ff

trace:    bra       LF27A

notrace:  clc
          bra       LF27B

          .byte     $ff

normal:   jmp       $fe84

          .byte     $ff

inverse:  jmp       $fe80

LF27A:    sec
LF27B:    ror       $f2
          rts

          .byte     $ff
          .byte     $ff

flash:    ldy       #$7f
          sty       $32
          rts

          .byte     $ff

himem:    jsr       LF798
          tax
          cpy       strend
          sbc       strend+1
          bcc       LF2BE
          sty       memsiz
          stx       memsiz+1
          sty       fretop
          stx       fretop+1
          rts

          .res      13,$ff

lomem:    jsr       LF798
          tax
          cpy       vartab
          sbc       vartab+1
          bcc       LF2BE
          txa
          cpy       memsiz
          sbc       memsiz+1
          bcs       LF2BE
          sty       vartab
          stx       vartab+1
          jmp       clearc

LF2BE:    jmp       iqerr

          .res      10,$ff

onerr:    cmp       #$ab
          bne       LF2E4
          jsr       chrget
          jsr       linget
          lda       linnum
          ldx       linnum+1
          sta       $f6
          stx       $f7
          lda       #$80
          sta       errflg
          jmp       rem

LF2E4:    jmp       snerr

          .byte     $ff
          .byte     $ff

handlerr:
          stx       $de
          ldx       #$01
@LF2ED:   lda       $79, x
          sta       $dc, x
          lda       curlin, x
          sta       $da, x
          lda       $f6, x
          sta       linnum, x
          lda       $f4, x
          sta       txtptr, x
          dex
          bpl       @LF2ED
          lda       $f8
          sta       $df
          jsr       L00B7
          jsr       fndlin
          jsr       LD95E
LF30D:    jmp       newstt

          .res      8,$ff

resume:   ldx       #$01
@LF31A:   lda       $dc, x
          sta       txtptr, x
          lda       $da, x
          sta       curlin, x
          dex
          bpl       @LF31A
          nop
          nop
          nop
          ldx       $df
          txs
          bra       LF30D

          .byte     $ff
          .byte     $ff
          .byte     $ff
          .byte     $ff

del:      bcs       LF2E4
          jmp       LD480

LF336:    ldx       lowtr
          lda       lowtr+1
          stx       dest
          sta       dest+1
          rts

LF33F:    stx       index
          sta       index+1
          txa
          sec
          sbc       prgend
          sta       fac
          tay
          lda       prgend
          sta       index
          lda       index+1
          bcs       @LF354
          dec       index+1
@LF354:   sbc       prgend+1
          tax
          sec
          lda       dest
          sbc       fac
          sta       dest
          bcs       @LF362
          dec       dest+1
@LF362:   lda       (index), y
          sta       (dest), y
          iny
          bne       @LF362
          inc       index+1
          inc       dest+1
          inx
          bne       @LF362
          lda       dest
          sta       vartab
          lda       dest+1
          sta       vartab+1
          rts

          .res      23,$ff

gr:       stx       $c054
          stx       $c056
          jmp       $fb40

text:     stx       $c054
          jsr       $fb39
          rts

LF3A0:    jsr       LF3B9
          beq       LF3B8
LF3A5:    inx
          lda       $01ff, x
          beq       LF3B8
          iny
          sta       $01fb, y
          cmp       #$22
          beq       LF3A0
          cmp       #$3b
          bne       LF3A5
          txa
LF3B8:    rts

LF3B9:    inx
          lda       $01ff, x
          beq       @LF3C7
          iny
          sta       $01fb, y
          cmp       #$22
          bne       LF3B9
@LF3C7:   lda       $01ff, x
          rts

LF3CB:    cmp       #$61
          bcc       @LF3D1
          sbc       #$20
@LF3D1:   rts

          .res      6,$ff

hgr2:     lda       #$40
          stx       $c052
          stx       $c055
          bne       sethpg              ; ALWAYS

hgr:      stx       $c053
          stx       $c054
          lda       #$20
sethpg:   sta       $e6
          stx       $c050
          stx       $c057
          bne       @LF3FE              ; ALWAYS

          bra       @LF3F8

          lda       $1c
@LF3F8:   phx
          jsr       LF4C4
          bra       @LF401

@LF3FE:   phx
          ldx       #$00
@LF401:   stz       $26
          ldy       $e6
          sty       $27
          lda       #$20
          sta       $d0
          ldy       #$00
          jmp       LF4E0

          .byte     $ff

hposn:    sta       $e2
          sty       $e1
          stx       $e0
          sta       $f5
          sty       $f4
          stx       $f3
          lda       $e4
          jsr       LF44E
          jsr       LF48C
          ldx       #$f9
          lda       $30
@LF429:   cmp       $c907, x
          beq       @LF431
          inx
          bne       @LF429
@LF431:   rts

          .res      6,$ff

          txa
          sta       $f3
          sty       $f4
          sta       $cfff
          sta       $c200
          bra       LF4A0

          .res      9,$ff

LF44E:    jsr       LF4C4
          stx       $ea
          rts

          .byte     $ff
          .byte     $ff
          .byte     $ff

hplot0:   jsr       hposn
          bra       LF47D

LF45C:    lda       $30
          and       #$7f
          eor       ($26), y
          sta       ($26), y
          rts

          bpl       LF471
          lda       $f3
          bne       @LF46D
          dec       $f4
@LF46D:   dec       $f3
          bra       LF4DA

LF471:    inc       $f3
          bne       LF4DA
          inc       $f4
          bra       LF4DA

          bit       $e3
          bmi       LF45C
LF47D:    lda       $1c
LF47F:    eor       ($26), y
          and       $30
          eor       ($26), y
          sta       ($26), y
          rts

          .byte     $ff
          .byte     $ff

          bra       LF471

LF48C:    sta       $cfff
          sta       $c200
          ldy       $f5
          lda       $cc41, y
          sta       $26
          lda       $cd01, y
          ora       $e6
          sta       $27
LF4A0:    ldy       $f3
          lda       $f4
          bne       @LF4AE
          ldx       $ca00, y
          lda       $cb00, y
          bra       @LF4B4

@LF4AE:   ldx       $ca04, y
          lda       $cc00, y
@LF4B4:   stx       $30
          tay
          sty       $e5
          and       #$01
          ora       $ea
          tax
          lda       LF6D0, x
          sta       $1c
          rts

LF4C4:    ldx       #$0e
@LF4C6:   cmp       LF6D0, x
          beq       @LF4CF
          dex
          dex
          bne       @LF4C6
@LF4CF:   rts

          .byte     $ff
          .byte     $ff
          .byte     $ff

          bmi       @LF4D8
          jmp       LF5CD

@LF4D8:   inc       $f5
LF4DA:    phx
          jsr       LF48C
          plx
          rts

LF4E0:    lda       LF6D0, x
          sta       ($26), y
          iny
          lda       LF6D1, x
          sta       ($26), y
          iny
          bne       LF4E0
          inc       $27
          dec       $d0
          bne       LF4E0
          lda       $e4
          jsr       LF44E
          plx
          rts

          .res      9,$ff

          inc       $f5
          clc
          lda       #$04
          adc       $27
          bit       #$1c
          bne       @LF52C
          and       #$03
          cmp       #$03
          clc
          bne       @LF522
          lda       $26
          bpl       @LF524
          adc       #$a8
          sta       $26
          lda       #$e0
          bra       @LF52A

@LF522:   lda       $26
@LF524:   adc       #$80
          sta       $26
          lda       #$e4
@LF52A:   adc       $27
@LF52C:   sta       $27
          rts

          .res      11,$ff

hglin:    pha
          phx
          tya
          ply
          plx
          jmp       LF672

LF542:    lda       $d2
          sta       $d4
          clc
          adc       $1d
          sta       $d0
          lda       $d3
          sta       $d5
          adc       #$00
          ldx       $d0
          bne       @LF556
          txa
@LF556:   sta       $d1
          sta       $cfff
          sta       $c200
@LF55E:   sec
          lda       $d4
          sbc       $1d
          sta       $d4
          bcs       @LF5A5
          dec       $d5
          bpl       @LF5A5
@LF56B:   bit       L00CD
          bvc       @LF573
          inc       $f5
          bra       @LF575

@LF573:   dec       $f5
@LF575:   ldy       $f5
          lda       $cc41, y
          sta       $26
          lda       $cd01, y
          ora       $e6
          sta       $27
          ldy       $e5
          lda       $1c
          eor       ($26), y
          and       $30
          eor       ($26), y
          sta       ($26), y
          dec       $d0
          bne       @LF597
          dec       $d1
          bmi       LF608
@LF597:   lda       $d4
          adc       $d2
          sta       $d4
          lda       $d5
          adc       $d3
          sta       $d5
          bcc       @LF56B
@LF5A5:   bit       L00CD
          bpl       @LF5B1
          inc       $f3
          bne       @LF5B9
          inc       $f4
          bra       @LF5B9

@LF5B1:   lda       $f3
          bne       @LF5B7
          dec       $f4
@LF5B7:   dec       $f3
@LF5B9:   jsr       LF4A0
          jsr       LF47F
          dec       $d0
          bne       @LF55E
          dec       $d1
          bmi       LF608
          bpl       @LF55E

          .byte     $ff
          .byte     $ff

          bra       LF608

LF5CD:    dec       $f5
          clc
          phx
          ldx       #$fc
          lda       $27
          bit       #$1c
          bne       @LF5F0
          phy
          ldx       #$1b
          ldy       #$80
          bit       #$03
          bne       @LF5EA
          lda       $26
          bmi       @LF5EA
          ldx       #$1f
          ldy       #$58
@LF5EA:   tya
          adc       $26
          sta       $26
          ply
@LF5F0:   txa
          adc       $27
          sta       $27
          plx
          rts

          .res      10,$ff

draw0:    sty       $1b
          stx       $1a
draw1:    clc
          bra       LF662

LF608:    ldx       #$02
@LF60A:   lda       $f3, x
          sta       $e0, x
          dex
          bpl       @LF60A
          rts

LF612:    jsr       LF7A7
          sta       $2c
          jsr       chkcom
          jsr       LF7A7
          cmp       $2c
          bcc       @LF626
          tay
          lda       $2c
          sty       $2c
@LF626:   pha
          jsr       LF7C4
          jsr       LF7AA
          ply
          jmp       $f819

LF631:    jsr       LF7AA
          sta       $2d
          jsr       chkcom
          jsr       LF7AA
          cmp       $2d
          bcc       @LF645
          tay
          lda       $2d
          sty       $2d
@LF645:   pha
          jsr       LF7C4
          jsr       LF7A7
          tay
          pla
          jmp       $f828

          .res      12,$ff

xdraw0:   sty       $1b
          stx       $1a
          sec
LF662:    sta       $cfff
          sta       $c200
          ror       $e3
          sta       $f9
          jsr       LF48C
          jmp       $cdc9

LF672:    sta       $cfff
          sta       $c200
          sec
          sbc       $f5
          sta       $1d
          ror       L00CD
          bmi       @LF688
          lda       #$00
          sec
          sbc       $1d
          sta       $1d
@LF688:   txa
          sec
          sbc       $f3
          sta       $d2
          tya
          sbc       $f4
          sta       $d3
          ror       L00CD
          bmi       @LF6A4
          lda       #$00
          sec
          sbc       $d2
          sta       $d2
          lda       #$00
          sbc       $d3
          sta       $d3
@LF6A4:   ora       $d2
          ora       $1d
          beq       @LF6B2
          ldy       $e5
          jsr       LF47D
          jmp       LF542

@LF6B2:   rts

          .res      6,$ff

hfns:     jsr       LF798
          pha
          cpy       #$18
          sbc       #$01
          bcs       @LF6CD
          phy
          jsr       chkcom
          jsr       LF7AD
          plx
          ply
          rts

@LF6CD:   jmp       iqerr

LF6D0:    .byte     $00
LF6D1:    .byte     $00
          .byte     $2a
          .byte     $55
          .byte     $55
          .byte     $2a
          .byte     $7f
          .byte     $7f
          .byte     $80
          .byte     $80
          .byte     $aa
          .byte     $d5
          .byte     $d5
          .byte     $aa
          .byte     $ff
          .byte     $ff

LF6E0:    tax
          lda       LF6D0, x
          sta       $e4
          rts

          .byte     $ff
          .byte     $ff

hcolor:   jsr       LF7A1
          nop
          nop
          nop
          nop
          txa
          asl
          sta       $ea
          bra       LF6E0

          .byte     $00
          .byte     $2a
          .byte     $55
          .byte     $7f
          .byte     $80
          .byte     $aa
          .byte     $d5
          .byte     $ff

hplot:    eor       #$c1
          beq       @LF70D
          jsr       hfns
          jsr       hposn
          jsr       LF47D
          bra       @LF716

@LF70D:   jsr       chrget
          jsr       hfns
          jsr       LF672
@LF716:   lda       (txtptr)
          eor       #$c1
          beq       @LF70D
          rts

          .byte     $ff
          .byte     $ff
          .byte     $ff
          .byte     $ff

rot:      jsr       LF7BF
          sta       $f9
          rts

scale:    jsr       LF7BF
          sta       $e7
          rts

LF72D:    jmp       iqerr

          stx       $e5
          bra       LF775

LF734:    jsr       LF7BF
          sta       $e5
          jsr       L00B7
          cmp       #tk_at
          bne       @LF74C
          jsr       chrget
          jsr       hfns
          sta       $f5
          stx       $f3
          sty       $f4
@LF74C:   jsr       LF775
          jsr       LF48C
          sta       $cfff
          sta       $c200
          jmp       $cdc9

          .res      14,$ff

draw:     lda       #$00
          sta       $e3
          beq       LF734               ; ALWAYS

xdraw:    lda       #$80
          sta       $e3
          bne       LF734               ; ALWAYS

LF775:    lda       ($e8)
          cmp       $e5
          bcc       LF72D
          ldx       #$00
          lda       $e5
          asl
          bcc       @LF783
          inx
@LF783:   jsr       @LF78D
          ldy       #$01
          lda       ($1a), y
          tax
          lda       ($1a)
@LF78D:   clc
          adc       $e8
          sta       $1a
          txa
          adc       $e9
          sta       $1b
          rts

LF798:    jsr       frmnum
          jmp       getadr

LF79E:    ldx       #$19
          .byte     $2C
LF7A1:    ldx       #$08
          .byte     $2C
LF7A4:    ldx       #$18
          .byte     $2C
LF7A7:    ldx       #$28
          .byte     $2C
LF7AA:    ldx       #$30
          .byte     $2C
LF7AD:    ldx       #$C0
          phx
          jsr       getbyt
          pla
          sta       fac
          cpx       fac
          bcs       @LF7BC
          txa
          rts

@LF7BC:   jmp       iqerr

LF7BF:    jsr       getbyt
          txa
          rts

LF7C4:    lda       #tk_at
          jmp       synchr

LF7C9:    tax
          jsr       crdo
          txa
LF7CE:    sec
          sbc       fac
          bcs       LF7C9
          adc       fac
          sta       $24
          rts

          .byte     $ff

          ldx       #$40
          stx       $14
          jsr       ptrget
          stz       $14
          rts

          .byte     $ff
          .byte     $ff
          .byte     $ff
          .byte     $ff

htab:     jsr       LE74F
          dex
          txa
          ldx       #40
.ifdef    iie
          bit       $C01F
          bpl       @1
          ldx       #80
@1:
.endif
          stx       fac
          beq       LF7CE               ; ALWAYS

          .res      $F800-*, $FF
